// Generated by CoffeeScript 1.12.7
var ALPHA_MASK, BLUE_MASK, DEBUG_UI, DOWN, FACE_BACK, FACE_BOTTOM, FACE_FRONT, FACE_LEFT, FACE_RIGHT, FACE_TOP, GREEN_MASK, MAX_FACES_PER_BATCH, Matrix4x4, RED_MASK, UP, VERTS_PER_FACE, Vec3, XYZs, addElementButton, addTagButton, background, backgroundColor, boxDottedStroke, boxStroke, bringUpElementList, cam, camera, cameraDirectionX, cameraDirectionY, cameraDirectionZ, cameraFOV, cameraX, cameraY, cameraZ, canvasElement, canvasHeight, canvasWidth, chooseElementByName, clearAllSlots, colorIntFromRGB, colorIntToGLArray, colorModeA, colorModeX, colorModeY, colorModeZ, containerBox, createProgramObject, curContext, curContextCache, currentElementList, currentFillColor, currentStrokeColor, currentlyOpenModal, dismissExamplesModal, dismissModal, dismissNavigationHelpModal, doFill, doStroke, dottedLine, elementChosenByUserToBeAddedToWorld, elementColor, elementDensity, elementName, elementSelectList, elements, elementsCount, elementsInTag, examplesModal, face, faceBuffer, faceVerts, facesInBatchSoFar, fill, fillStyle, flushFaces, fps_frameCount, fragmentShaderSrcFaces, fragmentShaderSrcLines, fragmentShaderSrcRects, fromCameraCalculateMoveOf, frustum, getGLContext, getUrlVars, gridSizeX, gridSizeY, gridSizeZ, handleKeydown, handleKeyup, horizontalMotionProbability, initCanvasWebGLAndCamera, initMainDataStructures, initUI, instrumentation_countParticles, instrumentation_countParticles_t0, instrumentation_countParticles_tf, invertHorizMouseDrag, isKeyPressed, justInFrontOfRayCastSlot, keyPressed, keyboardMouseHelpModal, lastSelectedForTag, lastUpdate, last_fps_count_time, line, lineBuffer, modelView, mouseDraggedLeftButton, mouseSensitivity, mouseX, mouseY, neighborProbability, newArray, noFill, noStroke, numberOfParticles, openExamplesModal, openKeyboardMouseHelpModal, particleAt, particleNextTickAt, particlesMotion, particlesMotion_t0, particlesMotion_tf, particlesReactions, particlesReactions_t0, particlesReactions_tf, pauseReactionsAndMotion, pauseRendering, perm4, perm5, perm6, perspective, physicsMode, pitch, placeElement, previousMouseX, previousMouseY, programObjectFaces, programObjectLines, programObjectRects, projection, rayCast, rayCastSlot, reactionOptions, rect, rectBuffer, rectVerts, renderCubes, render_t0, render_tf, scenario1, scenario10, scenario11, scenario12, scenario13, scenario14, scenario15, scenario16, scenario17, scenario18, scenario19, scenario2, scenario3, scenario4, scenario5, scenario6, scenario7, scenario8, scenario9, shuffledDirections, shuffledProbs, size, slowDown, smoothThreshold, smoothed, smoothedValue, smoothed_FWD, smoothed_PITCH, smoothed_SIDE, smoothed_UP, smoothed_YAW, smoothing, startSelectedExample, startSelectedExampleAndDismissExamplesModal, startingTime, stroke, strokeStyle, tagButtonPressed, tags, tick, ticks, transmutationProbability, transmutationTo, uElementIDAndSide, uElementsColors, uniformMatrix, uniformf, uniformi, updateCamera, updateChosenItemBasedOnSelect, userManuallyClickedOnSelectListEntry, vertexAttribPointer, vertexShaderSrcFaces, vertexShaderSrcLines, vertexShaderSrcRects, verticalMotionProbability, workSpaceX, workSpaceY, workSpaceZ, yaw,
  slice = [].slice,
  hasProp = {}.hasOwnProperty;

UP = -0.8;

DOWN = 0.8;

elements = {
  "Void": {
    rgb: [0, 0, 0],
    density: 0,
    nextToThese: ["Torch", "WaterFountain", "OilFountain"],
    becomesRespectivelyThis: ["Fire", "Water", "Oil"],
    withRespectiveProbs: [1, 1, 1]
  },
  "Wall": {
    tags: ["solid"],
    rgb: [200, 200, 200],
    density: 1
  },
  "Fire": {
    tags: ["flammable"],
    rgb: [255, 0, 0],
    density: 0.01,
    verticalMoveProb: UP,
    horizontalMoveProb: 0.25,
    transmutatesTo: "Void",
    transmutationProb: 0.1,
    nextToThese: ["Water", "Steam"],
    becomesRespectivelyThis: ["Void", "Void"],
    withRespectiveProbs: [1, 1]
  },
  "Water": {
    tags: ["liquid"],
    rgb: [0, 0, 255],
    density: 0.5,
    verticalMoveProb: DOWN,
    horizontalMoveProb: 0.5,
    nextToThese: ["Plant", "Fire"],
    becomesRespectivelyThis: ["Plant", "Steam"],
    withRespectiveProbs: [0.01, 1]
  },
  "Steam": {
    tags: ["gas"],
    rgb: [150, 100, 255],
    density: 0.3,
    verticalMoveProb: UP,
    horizontalMoveProb: 0.25,
    transmutatesTo: "Water",
    transmutationProb: 0.01
  },
  "Plant": {
    tags: ["solid"],
    rgb: [0, 255, 0],
    density: 1,
    nextToThese: ["Fire"],
    becomesRespectivelyThis: ["Fire"],
    withRespectiveProbs: [1]
  },
  "Oil": {
    tags: ["liquid", "flammable"],
    rgb: [150, 98, 0],
    density: 0.4,
    verticalMoveProb: DOWN,
    horizontalMoveProb: 0.5,
    nextToThese: ["Fire"],
    becomesRespectivelyThis: ["Fire"],
    withRespectiveProbs: [1]
  },
  "Torch": {
    tags: ["flammable"],
    rgb: [100, 100, 0],
    density: 1
  },
  "WaterFountain": {
    tags: ["liquid"],
    rgb: [0, 0, 150],
    density: 1
  },
  "OilFountain": {
    tags: ["liquid", "flammable"],
    rgb: [200, 100, 50],
    density: 1
  },
  "Fuse": {
    tags: ["flammable", "solid"],
    rgb: [255, 0, 0],
    density: 1,
    nextToThese: ["BurntFuse", "Fire"],
    becomesRespectivelyThis: ["BurntFuse", "BurntFuse"],
    withRespectiveProbs: [1, 1]
  },
  "BurntFuse": {
    tags: ["solid"],
    rgb: [120, 40, 0],
    density: 1
  }
};

workSpaceX = 32;

workSpaceY = 32;

workSpaceZ = 32;

gridSizeX = 32;

gridSizeY = 32;

gridSizeZ = 32;

elementsCount = Object.keys(elements).length;

backgroundColor = [0, 0, 0];

mouseSensitivity = 0.003;

invertHorizMouseDrag = 1;

DEBUG_UI = false;

perm6 = [[0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 5, 4], [0, 1, 2, 4, 3, 5], [0, 1, 2, 4, 5, 3], [0, 1, 2, 5, 3, 4], [0, 1, 2, 5, 4, 3], [0, 1, 3, 2, 4, 5], [0, 1, 3, 2, 5, 4], [0, 1, 3, 4, 2, 5], [0, 1, 3, 4, 5, 2], [0, 1, 3, 5, 2, 4], [0, 1, 3, 5, 4, 2], [0, 1, 4, 2, 3, 5], [0, 1, 4, 2, 5, 3], [0, 1, 4, 3, 2, 5], [0, 1, 4, 3, 5, 2], [0, 1, 4, 5, 2, 3], [0, 1, 4, 5, 3, 2], [0, 1, 5, 2, 3, 4], [0, 1, 5, 2, 4, 3], [0, 1, 5, 3, 2, 4], [0, 1, 5, 3, 4, 2], [0, 1, 5, 4, 2, 3], [0, 1, 5, 4, 3, 2], [0, 2, 1, 3, 4, 5], [0, 2, 1, 3, 5, 4], [0, 2, 1, 4, 3, 5], [0, 2, 1, 4, 5, 3], [0, 2, 1, 5, 3, 4], [0, 2, 1, 5, 4, 3], [0, 2, 3, 1, 4, 5], [0, 2, 3, 1, 5, 4], [0, 2, 3, 4, 1, 5], [0, 2, 3, 4, 5, 1], [0, 2, 3, 5, 1, 4], [0, 2, 3, 5, 4, 1], [0, 2, 4, 1, 3, 5], [0, 2, 4, 1, 5, 3], [0, 2, 4, 3, 1, 5], [0, 2, 4, 3, 5, 1], [0, 2, 4, 5, 1, 3], [0, 2, 4, 5, 3, 1], [0, 2, 5, 1, 3, 4], [0, 2, 5, 1, 4, 3], [0, 2, 5, 3, 1, 4], [0, 2, 5, 3, 4, 1], [0, 2, 5, 4, 1, 3], [0, 2, 5, 4, 3, 1], [0, 3, 1, 2, 4, 5], [0, 3, 1, 2, 5, 4], [0, 3, 1, 4, 2, 5], [0, 3, 1, 4, 5, 2], [0, 3, 1, 5, 2, 4], [0, 3, 1, 5, 4, 2], [0, 3, 2, 1, 4, 5], [0, 3, 2, 1, 5, 4], [0, 3, 2, 4, 1, 5], [0, 3, 2, 4, 5, 1], [0, 3, 2, 5, 1, 4], [0, 3, 2, 5, 4, 1], [0, 3, 4, 1, 2, 5], [0, 3, 4, 1, 5, 2], [0, 3, 4, 2, 1, 5], [0, 3, 4, 2, 5, 1], [0, 3, 4, 5, 1, 2], [0, 3, 4, 5, 2, 1], [0, 3, 5, 1, 2, 4], [0, 3, 5, 1, 4, 2], [0, 3, 5, 2, 1, 4], [0, 3, 5, 2, 4, 1], [0, 3, 5, 4, 1, 2], [0, 3, 5, 4, 2, 1], [0, 4, 1, 2, 3, 5], [0, 4, 1, 2, 5, 3], [0, 4, 1, 3, 2, 5], [0, 4, 1, 3, 5, 2], [0, 4, 1, 5, 2, 3], [0, 4, 1, 5, 3, 2], [0, 4, 2, 1, 3, 5], [0, 4, 2, 1, 5, 3], [0, 4, 2, 3, 1, 5], [0, 4, 2, 3, 5, 1], [0, 4, 2, 5, 1, 3], [0, 4, 2, 5, 3, 1], [0, 4, 3, 1, 2, 5], [0, 4, 3, 1, 5, 2], [0, 4, 3, 2, 1, 5], [0, 4, 3, 2, 5, 1], [0, 4, 3, 5, 1, 2], [0, 4, 3, 5, 2, 1], [0, 4, 5, 1, 2, 3], [0, 4, 5, 1, 3, 2], [0, 4, 5, 2, 1, 3], [0, 4, 5, 2, 3, 1], [0, 4, 5, 3, 1, 2], [0, 4, 5, 3, 2, 1], [0, 5, 1, 2, 3, 4], [0, 5, 1, 2, 4, 3], [0, 5, 1, 3, 2, 4], [0, 5, 1, 3, 4, 2], [0, 5, 1, 4, 2, 3], [0, 5, 1, 4, 3, 2], [0, 5, 2, 1, 3, 4], [0, 5, 2, 1, 4, 3], [0, 5, 2, 3, 1, 4], [0, 5, 2, 3, 4, 1], [0, 5, 2, 4, 1, 3], [0, 5, 2, 4, 3, 1], [0, 5, 3, 1, 2, 4], [0, 5, 3, 1, 4, 2], [0, 5, 3, 2, 1, 4], [0, 5, 3, 2, 4, 1], [0, 5, 3, 4, 1, 2], [0, 5, 3, 4, 2, 1], [0, 5, 4, 1, 2, 3], [0, 5, 4, 1, 3, 2], [0, 5, 4, 2, 1, 3], [0, 5, 4, 2, 3, 1], [0, 5, 4, 3, 1, 2], [0, 5, 4, 3, 2, 1], [1, 0, 2, 3, 4, 5], [1, 0, 2, 3, 5, 4], [1, 0, 2, 4, 3, 5], [1, 0, 2, 4, 5, 3], [1, 0, 2, 5, 3, 4], [1, 0, 2, 5, 4, 3], [1, 0, 3, 2, 4, 5], [1, 0, 3, 2, 5, 4], [1, 0, 3, 4, 2, 5], [1, 0, 3, 4, 5, 2], [1, 0, 3, 5, 2, 4], [1, 0, 3, 5, 4, 2], [1, 0, 4, 2, 3, 5], [1, 0, 4, 2, 5, 3], [1, 0, 4, 3, 2, 5], [1, 0, 4, 3, 5, 2], [1, 0, 4, 5, 2, 3], [1, 0, 4, 5, 3, 2], [1, 0, 5, 2, 3, 4], [1, 0, 5, 2, 4, 3], [1, 0, 5, 3, 2, 4], [1, 0, 5, 3, 4, 2], [1, 0, 5, 4, 2, 3], [1, 0, 5, 4, 3, 2], [1, 2, 0, 3, 4, 5], [1, 2, 0, 3, 5, 4], [1, 2, 0, 4, 3, 5], [1, 2, 0, 4, 5, 3], [1, 2, 0, 5, 3, 4], [1, 2, 0, 5, 4, 3], [1, 2, 3, 0, 4, 5], [1, 2, 3, 0, 5, 4], [1, 2, 3, 4, 0, 5], [1, 2, 3, 4, 5, 0], [1, 2, 3, 5, 0, 4], [1, 2, 3, 5, 4, 0], [1, 2, 4, 0, 3, 5], [1, 2, 4, 0, 5, 3], [1, 2, 4, 3, 0, 5], [1, 2, 4, 3, 5, 0], [1, 2, 4, 5, 0, 3], [1, 2, 4, 5, 3, 0], [1, 2, 5, 0, 3, 4], [1, 2, 5, 0, 4, 3], [1, 2, 5, 3, 0, 4], [1, 2, 5, 3, 4, 0], [1, 2, 5, 4, 0, 3], [1, 2, 5, 4, 3, 0], [1, 3, 0, 2, 4, 5], [1, 3, 0, 2, 5, 4], [1, 3, 0, 4, 2, 5], [1, 3, 0, 4, 5, 2], [1, 3, 0, 5, 2, 4], [1, 3, 0, 5, 4, 2], [1, 3, 2, 0, 4, 5], [1, 3, 2, 0, 5, 4], [1, 3, 2, 4, 0, 5], [1, 3, 2, 4, 5, 0], [1, 3, 2, 5, 0, 4], [1, 3, 2, 5, 4, 0], [1, 3, 4, 0, 2, 5], [1, 3, 4, 0, 5, 2], [1, 3, 4, 2, 0, 5], [1, 3, 4, 2, 5, 0], [1, 3, 4, 5, 0, 2], [1, 3, 4, 5, 2, 0], [1, 3, 5, 0, 2, 4], [1, 3, 5, 0, 4, 2], [1, 3, 5, 2, 0, 4], [1, 3, 5, 2, 4, 0], [1, 3, 5, 4, 0, 2], [1, 3, 5, 4, 2, 0], [1, 4, 0, 2, 3, 5], [1, 4, 0, 2, 5, 3], [1, 4, 0, 3, 2, 5], [1, 4, 0, 3, 5, 2], [1, 4, 0, 5, 2, 3], [1, 4, 0, 5, 3, 2], [1, 4, 2, 0, 3, 5], [1, 4, 2, 0, 5, 3], [1, 4, 2, 3, 0, 5], [1, 4, 2, 3, 5, 0], [1, 4, 2, 5, 0, 3], [1, 4, 2, 5, 3, 0], [1, 4, 3, 0, 2, 5], [1, 4, 3, 0, 5, 2], [1, 4, 3, 2, 0, 5], [1, 4, 3, 2, 5, 0], [1, 4, 3, 5, 0, 2], [1, 4, 3, 5, 2, 0], [1, 4, 5, 0, 2, 3], [1, 4, 5, 0, 3, 2], [1, 4, 5, 2, 0, 3], [1, 4, 5, 2, 3, 0], [1, 4, 5, 3, 0, 2], [1, 4, 5, 3, 2, 0], [1, 5, 0, 2, 3, 4], [1, 5, 0, 2, 4, 3], [1, 5, 0, 3, 2, 4], [1, 5, 0, 3, 4, 2], [1, 5, 0, 4, 2, 3], [1, 5, 0, 4, 3, 2], [1, 5, 2, 0, 3, 4], [1, 5, 2, 0, 4, 3], [1, 5, 2, 3, 0, 4], [1, 5, 2, 3, 4, 0], [1, 5, 2, 4, 0, 3], [1, 5, 2, 4, 3, 0], [1, 5, 3, 0, 2, 4], [1, 5, 3, 0, 4, 2], [1, 5, 3, 2, 0, 4], [1, 5, 3, 2, 4, 0], [1, 5, 3, 4, 0, 2], [1, 5, 3, 4, 2, 0], [1, 5, 4, 0, 2, 3], [1, 5, 4, 0, 3, 2], [1, 5, 4, 2, 0, 3], [1, 5, 4, 2, 3, 0], [1, 5, 4, 3, 0, 2], [1, 5, 4, 3, 2, 0], [2, 0, 1, 3, 4, 5], [2, 0, 1, 3, 5, 4], [2, 0, 1, 4, 3, 5], [2, 0, 1, 4, 5, 3], [2, 0, 1, 5, 3, 4], [2, 0, 1, 5, 4, 3], [2, 0, 3, 1, 4, 5], [2, 0, 3, 1, 5, 4], [2, 0, 3, 4, 1, 5], [2, 0, 3, 4, 5, 1], [2, 0, 3, 5, 1, 4], [2, 0, 3, 5, 4, 1], [2, 0, 4, 1, 3, 5], [2, 0, 4, 1, 5, 3], [2, 0, 4, 3, 1, 5], [2, 0, 4, 3, 5, 1], [2, 0, 4, 5, 1, 3], [2, 0, 4, 5, 3, 1], [2, 0, 5, 1, 3, 4], [2, 0, 5, 1, 4, 3], [2, 0, 5, 3, 1, 4], [2, 0, 5, 3, 4, 1], [2, 0, 5, 4, 1, 3], [2, 0, 5, 4, 3, 1], [2, 1, 0, 3, 4, 5], [2, 1, 0, 3, 5, 4], [2, 1, 0, 4, 3, 5], [2, 1, 0, 4, 5, 3], [2, 1, 0, 5, 3, 4], [2, 1, 0, 5, 4, 3], [2, 1, 3, 0, 4, 5], [2, 1, 3, 0, 5, 4], [2, 1, 3, 4, 0, 5], [2, 1, 3, 4, 5, 0], [2, 1, 3, 5, 0, 4], [2, 1, 3, 5, 4, 0], [2, 1, 4, 0, 3, 5], [2, 1, 4, 0, 5, 3], [2, 1, 4, 3, 0, 5], [2, 1, 4, 3, 5, 0], [2, 1, 4, 5, 0, 3], [2, 1, 4, 5, 3, 0], [2, 1, 5, 0, 3, 4], [2, 1, 5, 0, 4, 3], [2, 1, 5, 3, 0, 4], [2, 1, 5, 3, 4, 0], [2, 1, 5, 4, 0, 3], [2, 1, 5, 4, 3, 0], [2, 3, 0, 1, 4, 5], [2, 3, 0, 1, 5, 4], [2, 3, 0, 4, 1, 5], [2, 3, 0, 4, 5, 1], [2, 3, 0, 5, 1, 4], [2, 3, 0, 5, 4, 1], [2, 3, 1, 0, 4, 5], [2, 3, 1, 0, 5, 4], [2, 3, 1, 4, 0, 5], [2, 3, 1, 4, 5, 0], [2, 3, 1, 5, 0, 4], [2, 3, 1, 5, 4, 0], [2, 3, 4, 0, 1, 5], [2, 3, 4, 0, 5, 1], [2, 3, 4, 1, 0, 5], [2, 3, 4, 1, 5, 0], [2, 3, 4, 5, 0, 1], [2, 3, 4, 5, 1, 0], [2, 3, 5, 0, 1, 4], [2, 3, 5, 0, 4, 1], [2, 3, 5, 1, 0, 4], [2, 3, 5, 1, 4, 0], [2, 3, 5, 4, 0, 1], [2, 3, 5, 4, 1, 0], [2, 4, 0, 1, 3, 5], [2, 4, 0, 1, 5, 3], [2, 4, 0, 3, 1, 5], [2, 4, 0, 3, 5, 1], [2, 4, 0, 5, 1, 3], [2, 4, 0, 5, 3, 1], [2, 4, 1, 0, 3, 5], [2, 4, 1, 0, 5, 3], [2, 4, 1, 3, 0, 5], [2, 4, 1, 3, 5, 0], [2, 4, 1, 5, 0, 3], [2, 4, 1, 5, 3, 0], [2, 4, 3, 0, 1, 5], [2, 4, 3, 0, 5, 1], [2, 4, 3, 1, 0, 5], [2, 4, 3, 1, 5, 0], [2, 4, 3, 5, 0, 1], [2, 4, 3, 5, 1, 0], [2, 4, 5, 0, 1, 3], [2, 4, 5, 0, 3, 1], [2, 4, 5, 1, 0, 3], [2, 4, 5, 1, 3, 0], [2, 4, 5, 3, 0, 1], [2, 4, 5, 3, 1, 0], [2, 5, 0, 1, 3, 4], [2, 5, 0, 1, 4, 3], [2, 5, 0, 3, 1, 4], [2, 5, 0, 3, 4, 1], [2, 5, 0, 4, 1, 3], [2, 5, 0, 4, 3, 1], [2, 5, 1, 0, 3, 4], [2, 5, 1, 0, 4, 3], [2, 5, 1, 3, 0, 4], [2, 5, 1, 3, 4, 0], [2, 5, 1, 4, 0, 3], [2, 5, 1, 4, 3, 0], [2, 5, 3, 0, 1, 4], [2, 5, 3, 0, 4, 1], [2, 5, 3, 1, 0, 4], [2, 5, 3, 1, 4, 0], [2, 5, 3, 4, 0, 1], [2, 5, 3, 4, 1, 0], [2, 5, 4, 0, 1, 3], [2, 5, 4, 0, 3, 1], [2, 5, 4, 1, 0, 3], [2, 5, 4, 1, 3, 0], [2, 5, 4, 3, 0, 1], [2, 5, 4, 3, 1, 0], [3, 0, 1, 2, 4, 5], [3, 0, 1, 2, 5, 4], [3, 0, 1, 4, 2, 5], [3, 0, 1, 4, 5, 2], [3, 0, 1, 5, 2, 4], [3, 0, 1, 5, 4, 2], [3, 0, 2, 1, 4, 5], [3, 0, 2, 1, 5, 4], [3, 0, 2, 4, 1, 5], [3, 0, 2, 4, 5, 1], [3, 0, 2, 5, 1, 4], [3, 0, 2, 5, 4, 1], [3, 0, 4, 1, 2, 5], [3, 0, 4, 1, 5, 2], [3, 0, 4, 2, 1, 5], [3, 0, 4, 2, 5, 1], [3, 0, 4, 5, 1, 2], [3, 0, 4, 5, 2, 1], [3, 0, 5, 1, 2, 4], [3, 0, 5, 1, 4, 2], [3, 0, 5, 2, 1, 4], [3, 0, 5, 2, 4, 1], [3, 0, 5, 4, 1, 2], [3, 0, 5, 4, 2, 1], [3, 1, 0, 2, 4, 5], [3, 1, 0, 2, 5, 4], [3, 1, 0, 4, 2, 5], [3, 1, 0, 4, 5, 2], [3, 1, 0, 5, 2, 4], [3, 1, 0, 5, 4, 2], [3, 1, 2, 0, 4, 5], [3, 1, 2, 0, 5, 4], [3, 1, 2, 4, 0, 5], [3, 1, 2, 4, 5, 0], [3, 1, 2, 5, 0, 4], [3, 1, 2, 5, 4, 0], [3, 1, 4, 0, 2, 5], [3, 1, 4, 0, 5, 2], [3, 1, 4, 2, 0, 5], [3, 1, 4, 2, 5, 0], [3, 1, 4, 5, 0, 2], [3, 1, 4, 5, 2, 0], [3, 1, 5, 0, 2, 4], [3, 1, 5, 0, 4, 2], [3, 1, 5, 2, 0, 4], [3, 1, 5, 2, 4, 0], [3, 1, 5, 4, 0, 2], [3, 1, 5, 4, 2, 0], [3, 2, 0, 1, 4, 5], [3, 2, 0, 1, 5, 4], [3, 2, 0, 4, 1, 5], [3, 2, 0, 4, 5, 1], [3, 2, 0, 5, 1, 4], [3, 2, 0, 5, 4, 1], [3, 2, 1, 0, 4, 5], [3, 2, 1, 0, 5, 4], [3, 2, 1, 4, 0, 5], [3, 2, 1, 4, 5, 0], [3, 2, 1, 5, 0, 4], [3, 2, 1, 5, 4, 0], [3, 2, 4, 0, 1, 5], [3, 2, 4, 0, 5, 1], [3, 2, 4, 1, 0, 5], [3, 2, 4, 1, 5, 0], [3, 2, 4, 5, 0, 1], [3, 2, 4, 5, 1, 0], [3, 2, 5, 0, 1, 4], [3, 2, 5, 0, 4, 1], [3, 2, 5, 1, 0, 4], [3, 2, 5, 1, 4, 0], [3, 2, 5, 4, 0, 1], [3, 2, 5, 4, 1, 0], [3, 4, 0, 1, 2, 5], [3, 4, 0, 1, 5, 2], [3, 4, 0, 2, 1, 5], [3, 4, 0, 2, 5, 1], [3, 4, 0, 5, 1, 2], [3, 4, 0, 5, 2, 1], [3, 4, 1, 0, 2, 5], [3, 4, 1, 0, 5, 2], [3, 4, 1, 2, 0, 5], [3, 4, 1, 2, 5, 0], [3, 4, 1, 5, 0, 2], [3, 4, 1, 5, 2, 0], [3, 4, 2, 0, 1, 5], [3, 4, 2, 0, 5, 1], [3, 4, 2, 1, 0, 5], [3, 4, 2, 1, 5, 0], [3, 4, 2, 5, 0, 1], [3, 4, 2, 5, 1, 0], [3, 4, 5, 0, 1, 2], [3, 4, 5, 0, 2, 1], [3, 4, 5, 1, 0, 2], [3, 4, 5, 1, 2, 0], [3, 4, 5, 2, 0, 1], [3, 4, 5, 2, 1, 0], [3, 5, 0, 1, 2, 4], [3, 5, 0, 1, 4, 2], [3, 5, 0, 2, 1, 4], [3, 5, 0, 2, 4, 1], [3, 5, 0, 4, 1, 2], [3, 5, 0, 4, 2, 1], [3, 5, 1, 0, 2, 4], [3, 5, 1, 0, 4, 2], [3, 5, 1, 2, 0, 4], [3, 5, 1, 2, 4, 0], [3, 5, 1, 4, 0, 2], [3, 5, 1, 4, 2, 0], [3, 5, 2, 0, 1, 4], [3, 5, 2, 0, 4, 1], [3, 5, 2, 1, 0, 4], [3, 5, 2, 1, 4, 0], [3, 5, 2, 4, 0, 1], [3, 5, 2, 4, 1, 0], [3, 5, 4, 0, 1, 2], [3, 5, 4, 0, 2, 1], [3, 5, 4, 1, 0, 2], [3, 5, 4, 1, 2, 0], [3, 5, 4, 2, 0, 1], [3, 5, 4, 2, 1, 0], [4, 0, 1, 2, 3, 5], [4, 0, 1, 2, 5, 3], [4, 0, 1, 3, 2, 5], [4, 0, 1, 3, 5, 2], [4, 0, 1, 5, 2, 3], [4, 0, 1, 5, 3, 2], [4, 0, 2, 1, 3, 5], [4, 0, 2, 1, 5, 3], [4, 0, 2, 3, 1, 5], [4, 0, 2, 3, 5, 1], [4, 0, 2, 5, 1, 3], [4, 0, 2, 5, 3, 1], [4, 0, 3, 1, 2, 5], [4, 0, 3, 1, 5, 2], [4, 0, 3, 2, 1, 5], [4, 0, 3, 2, 5, 1], [4, 0, 3, 5, 1, 2], [4, 0, 3, 5, 2, 1], [4, 0, 5, 1, 2, 3], [4, 0, 5, 1, 3, 2], [4, 0, 5, 2, 1, 3], [4, 0, 5, 2, 3, 1], [4, 0, 5, 3, 1, 2], [4, 0, 5, 3, 2, 1], [4, 1, 0, 2, 3, 5], [4, 1, 0, 2, 5, 3], [4, 1, 0, 3, 2, 5], [4, 1, 0, 3, 5, 2], [4, 1, 0, 5, 2, 3], [4, 1, 0, 5, 3, 2], [4, 1, 2, 0, 3, 5], [4, 1, 2, 0, 5, 3], [4, 1, 2, 3, 0, 5], [4, 1, 2, 3, 5, 0], [4, 1, 2, 5, 0, 3], [4, 1, 2, 5, 3, 0], [4, 1, 3, 0, 2, 5], [4, 1, 3, 0, 5, 2], [4, 1, 3, 2, 0, 5], [4, 1, 3, 2, 5, 0], [4, 1, 3, 5, 0, 2], [4, 1, 3, 5, 2, 0], [4, 1, 5, 0, 2, 3], [4, 1, 5, 0, 3, 2], [4, 1, 5, 2, 0, 3], [4, 1, 5, 2, 3, 0], [4, 1, 5, 3, 0, 2], [4, 1, 5, 3, 2, 0], [4, 2, 0, 1, 3, 5], [4, 2, 0, 1, 5, 3], [4, 2, 0, 3, 1, 5], [4, 2, 0, 3, 5, 1], [4, 2, 0, 5, 1, 3], [4, 2, 0, 5, 3, 1], [4, 2, 1, 0, 3, 5], [4, 2, 1, 0, 5, 3], [4, 2, 1, 3, 0, 5], [4, 2, 1, 3, 5, 0], [4, 2, 1, 5, 0, 3], [4, 2, 1, 5, 3, 0], [4, 2, 3, 0, 1, 5], [4, 2, 3, 0, 5, 1], [4, 2, 3, 1, 0, 5], [4, 2, 3, 1, 5, 0], [4, 2, 3, 5, 0, 1], [4, 2, 3, 5, 1, 0], [4, 2, 5, 0, 1, 3], [4, 2, 5, 0, 3, 1], [4, 2, 5, 1, 0, 3], [4, 2, 5, 1, 3, 0], [4, 2, 5, 3, 0, 1], [4, 2, 5, 3, 1, 0], [4, 3, 0, 1, 2, 5], [4, 3, 0, 1, 5, 2], [4, 3, 0, 2, 1, 5], [4, 3, 0, 2, 5, 1], [4, 3, 0, 5, 1, 2], [4, 3, 0, 5, 2, 1], [4, 3, 1, 0, 2, 5], [4, 3, 1, 0, 5, 2], [4, 3, 1, 2, 0, 5], [4, 3, 1, 2, 5, 0], [4, 3, 1, 5, 0, 2], [4, 3, 1, 5, 2, 0], [4, 3, 2, 0, 1, 5], [4, 3, 2, 0, 5, 1], [4, 3, 2, 1, 0, 5], [4, 3, 2, 1, 5, 0], [4, 3, 2, 5, 0, 1], [4, 3, 2, 5, 1, 0], [4, 3, 5, 0, 1, 2], [4, 3, 5, 0, 2, 1], [4, 3, 5, 1, 0, 2], [4, 3, 5, 1, 2, 0], [4, 3, 5, 2, 0, 1], [4, 3, 5, 2, 1, 0], [4, 5, 0, 1, 2, 3], [4, 5, 0, 1, 3, 2], [4, 5, 0, 2, 1, 3], [4, 5, 0, 2, 3, 1], [4, 5, 0, 3, 1, 2], [4, 5, 0, 3, 2, 1], [4, 5, 1, 0, 2, 3], [4, 5, 1, 0, 3, 2], [4, 5, 1, 2, 0, 3], [4, 5, 1, 2, 3, 0], [4, 5, 1, 3, 0, 2], [4, 5, 1, 3, 2, 0], [4, 5, 2, 0, 1, 3], [4, 5, 2, 0, 3, 1], [4, 5, 2, 1, 0, 3], [4, 5, 2, 1, 3, 0], [4, 5, 2, 3, 0, 1], [4, 5, 2, 3, 1, 0], [4, 5, 3, 0, 1, 2], [4, 5, 3, 0, 2, 1], [4, 5, 3, 1, 0, 2], [4, 5, 3, 1, 2, 0], [4, 5, 3, 2, 0, 1], [4, 5, 3, 2, 1, 0], [5, 0, 1, 2, 3, 4], [5, 0, 1, 2, 4, 3], [5, 0, 1, 3, 2, 4], [5, 0, 1, 3, 4, 2], [5, 0, 1, 4, 2, 3], [5, 0, 1, 4, 3, 2], [5, 0, 2, 1, 3, 4], [5, 0, 2, 1, 4, 3], [5, 0, 2, 3, 1, 4], [5, 0, 2, 3, 4, 1], [5, 0, 2, 4, 1, 3], [5, 0, 2, 4, 3, 1], [5, 0, 3, 1, 2, 4], [5, 0, 3, 1, 4, 2], [5, 0, 3, 2, 1, 4], [5, 0, 3, 2, 4, 1], [5, 0, 3, 4, 1, 2], [5, 0, 3, 4, 2, 1], [5, 0, 4, 1, 2, 3], [5, 0, 4, 1, 3, 2], [5, 0, 4, 2, 1, 3], [5, 0, 4, 2, 3, 1], [5, 0, 4, 3, 1, 2], [5, 0, 4, 3, 2, 1], [5, 1, 0, 2, 3, 4], [5, 1, 0, 2, 4, 3], [5, 1, 0, 3, 2, 4], [5, 1, 0, 3, 4, 2], [5, 1, 0, 4, 2, 3], [5, 1, 0, 4, 3, 2], [5, 1, 2, 0, 3, 4], [5, 1, 2, 0, 4, 3], [5, 1, 2, 3, 0, 4], [5, 1, 2, 3, 4, 0], [5, 1, 2, 4, 0, 3], [5, 1, 2, 4, 3, 0], [5, 1, 3, 0, 2, 4], [5, 1, 3, 0, 4, 2], [5, 1, 3, 2, 0, 4], [5, 1, 3, 2, 4, 0], [5, 1, 3, 4, 0, 2], [5, 1, 3, 4, 2, 0], [5, 1, 4, 0, 2, 3], [5, 1, 4, 0, 3, 2], [5, 1, 4, 2, 0, 3], [5, 1, 4, 2, 3, 0], [5, 1, 4, 3, 0, 2], [5, 1, 4, 3, 2, 0], [5, 2, 0, 1, 3, 4], [5, 2, 0, 1, 4, 3], [5, 2, 0, 3, 1, 4], [5, 2, 0, 3, 4, 1], [5, 2, 0, 4, 1, 3], [5, 2, 0, 4, 3, 1], [5, 2, 1, 0, 3, 4], [5, 2, 1, 0, 4, 3], [5, 2, 1, 3, 0, 4], [5, 2, 1, 3, 4, 0], [5, 2, 1, 4, 0, 3], [5, 2, 1, 4, 3, 0], [5, 2, 3, 0, 1, 4], [5, 2, 3, 0, 4, 1], [5, 2, 3, 1, 0, 4], [5, 2, 3, 1, 4, 0], [5, 2, 3, 4, 0, 1], [5, 2, 3, 4, 1, 0], [5, 2, 4, 0, 1, 3], [5, 2, 4, 0, 3, 1], [5, 2, 4, 1, 0, 3], [5, 2, 4, 1, 3, 0], [5, 2, 4, 3, 0, 1], [5, 2, 4, 3, 1, 0], [5, 3, 0, 1, 2, 4], [5, 3, 0, 1, 4, 2], [5, 3, 0, 2, 1, 4], [5, 3, 0, 2, 4, 1], [5, 3, 0, 4, 1, 2], [5, 3, 0, 4, 2, 1], [5, 3, 1, 0, 2, 4], [5, 3, 1, 0, 4, 2], [5, 3, 1, 2, 0, 4], [5, 3, 1, 2, 4, 0], [5, 3, 1, 4, 0, 2], [5, 3, 1, 4, 2, 0], [5, 3, 2, 0, 1, 4], [5, 3, 2, 0, 4, 1], [5, 3, 2, 1, 0, 4], [5, 3, 2, 1, 4, 0], [5, 3, 2, 4, 0, 1], [5, 3, 2, 4, 1, 0], [5, 3, 4, 0, 1, 2], [5, 3, 4, 0, 2, 1], [5, 3, 4, 1, 0, 2], [5, 3, 4, 1, 2, 0], [5, 3, 4, 2, 0, 1], [5, 3, 4, 2, 1, 0], [5, 4, 0, 1, 2, 3], [5, 4, 0, 1, 3, 2], [5, 4, 0, 2, 1, 3], [5, 4, 0, 2, 3, 1], [5, 4, 0, 3, 1, 2], [5, 4, 0, 3, 2, 1], [5, 4, 1, 0, 2, 3], [5, 4, 1, 0, 3, 2], [5, 4, 1, 2, 0, 3], [5, 4, 1, 2, 3, 0], [5, 4, 1, 3, 0, 2], [5, 4, 1, 3, 2, 0], [5, 4, 2, 0, 1, 3], [5, 4, 2, 0, 3, 1], [5, 4, 2, 1, 0, 3], [5, 4, 2, 1, 3, 0], [5, 4, 2, 3, 0, 1], [5, 4, 2, 3, 1, 0], [5, 4, 3, 0, 1, 2], [5, 4, 3, 0, 2, 1], [5, 4, 3, 1, 0, 2], [5, 4, 3, 1, 2, 0], [5, 4, 3, 2, 0, 1], [5, 4, 3, 2, 1, 0]];

perm5 = [[0, 1, 2, 3, 4], [0, 1, 2, 4, 3], [0, 1, 3, 2, 4], [0, 1, 3, 4, 2], [0, 1, 4, 2, 3], [0, 1, 4, 3, 2], [0, 2, 1, 3, 4], [0, 2, 1, 4, 3], [0, 2, 3, 1, 4], [0, 2, 3, 4, 1], [0, 2, 4, 1, 3], [0, 2, 4, 3, 1], [0, 3, 1, 2, 4], [0, 3, 1, 4, 2], [0, 3, 2, 1, 4], [0, 3, 2, 4, 1], [0, 3, 4, 1, 2], [0, 3, 4, 2, 1], [0, 4, 1, 2, 3], [0, 4, 1, 3, 2], [0, 4, 2, 1, 3], [0, 4, 2, 3, 1], [0, 4, 3, 1, 2], [0, 4, 3, 2, 1], [1, 0, 2, 3, 4], [1, 0, 2, 4, 3], [1, 0, 3, 2, 4], [1, 0, 3, 4, 2], [1, 0, 4, 2, 3], [1, 0, 4, 3, 2], [1, 2, 0, 3, 4], [1, 2, 0, 4, 3], [1, 2, 3, 0, 4], [1, 2, 3, 4, 0], [1, 2, 4, 0, 3], [1, 2, 4, 3, 0], [1, 3, 0, 2, 4], [1, 3, 0, 4, 2], [1, 3, 2, 0, 4], [1, 3, 2, 4, 0], [1, 3, 4, 0, 2], [1, 3, 4, 2, 0], [1, 4, 0, 2, 3], [1, 4, 0, 3, 2], [1, 4, 2, 0, 3], [1, 4, 2, 3, 0], [1, 4, 3, 0, 2], [1, 4, 3, 2, 0], [2, 0, 1, 3, 4], [2, 0, 1, 4, 3], [2, 0, 3, 1, 4], [2, 0, 3, 4, 1], [2, 0, 4, 1, 3], [2, 0, 4, 3, 1], [2, 1, 0, 3, 4], [2, 1, 0, 4, 3], [2, 1, 3, 0, 4], [2, 1, 3, 4, 0], [2, 1, 4, 0, 3], [2, 1, 4, 3, 0], [2, 3, 0, 1, 4], [2, 3, 0, 4, 1], [2, 3, 1, 0, 4], [2, 3, 1, 4, 0], [2, 3, 4, 0, 1], [2, 3, 4, 1, 0], [2, 4, 0, 1, 3], [2, 4, 0, 3, 1], [2, 4, 1, 0, 3], [2, 4, 1, 3, 0], [2, 4, 3, 0, 1], [2, 4, 3, 1, 0], [3, 0, 1, 2, 4], [3, 0, 1, 4, 2], [3, 0, 2, 1, 4], [3, 0, 2, 4, 1], [3, 0, 4, 1, 2], [3, 0, 4, 2, 1], [3, 1, 0, 2, 4], [3, 1, 0, 4, 2], [3, 1, 2, 0, 4], [3, 1, 2, 4, 0], [3, 1, 4, 0, 2], [3, 1, 4, 2, 0], [3, 2, 0, 1, 4], [3, 2, 0, 4, 1], [3, 2, 1, 0, 4], [3, 2, 1, 4, 0], [3, 2, 4, 0, 1], [3, 2, 4, 1, 0], [3, 4, 0, 1, 2], [3, 4, 0, 2, 1], [3, 4, 1, 0, 2], [3, 4, 1, 2, 0], [3, 4, 2, 0, 1], [3, 4, 2, 1, 0], [4, 0, 1, 2, 3], [4, 0, 1, 3, 2], [4, 0, 2, 1, 3], [4, 0, 2, 3, 1], [4, 0, 3, 1, 2], [4, 0, 3, 2, 1], [4, 1, 0, 2, 3], [4, 1, 0, 3, 2], [4, 1, 2, 0, 3], [4, 1, 2, 3, 0], [4, 1, 3, 0, 2], [4, 1, 3, 2, 0], [4, 2, 0, 1, 3], [4, 2, 0, 3, 1], [4, 2, 1, 0, 3], [4, 2, 1, 3, 0], [4, 2, 3, 0, 1], [4, 2, 3, 1, 0], [4, 3, 0, 1, 2], [4, 3, 0, 2, 1], [4, 3, 1, 0, 2], [4, 3, 1, 2, 0], [4, 3, 2, 0, 1], [4, 3, 2, 1, 0]];

perm4 = [[0, 1, 2, 3], [1, 0, 2, 3], [2, 0, 1, 3], [0, 2, 1, 3], [1, 2, 0, 3], [2, 1, 0, 3], [3, 1, 0, 2], [1, 3, 0, 2], [0, 3, 1, 2], [3, 0, 1, 2], [1, 0, 3, 2], [0, 1, 3, 2], [0, 2, 3, 1], [2, 0, 3, 1], [3, 0, 2, 1], [0, 3, 2, 1], [2, 3, 0, 1], [3, 2, 0, 1], [3, 2, 1, 0], [2, 3, 1, 0], [1, 3, 2, 0], [3, 1, 2, 0], [2, 1, 3, 0], [1, 2, 3, 0]];

canvasElement = document.getElementById('theCanvas');

getUrlVars = function() {
  var vars;
  vars = {};
  window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m, key, value) {
    vars[key] = value;
  });
  return vars;
};

physicsMode = parseInt(getUrlVars()["physicsMode"]);

slowDown = parseInt(getUrlVars()["slowDown"]);

newArray = function() {
  var _func, array, j, other, size, v;
  size = arguments[0], other = 3 <= arguments.length ? slice.call(arguments, 1, j = arguments.length - 1) : (j = 1, []), v = arguments[j++];
  _func = typeof v !== 'function' ? function() {
    return v;
  } : v;
  array = function() {
    var k, other, size, v;
    size = arguments[0], other = 3 <= arguments.length ? slice.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), v = arguments[k++];
    if (arguments.length === 1) {
      return size();
    }
    return Array.apply(null, Array(size)).map(function(e, i) {
      return array.apply(this, other.concat(v.bind(this, i)));
    });
  };
  other.unshift(size);
  other.push(_func);
  return array.apply(this, other);
};

elementChosenByUserToBeAddedToWorld = 0;

lastSelectedForTag = {};

chooseElementByName = function(name) {
  return elementChosenByUserToBeAddedToWorld = elementName.indexOf(name);
};

updateChosenItemBasedOnSelect = function() {
  var selectedTag;
  selectedTag = elementSelectList.item(elementSelectList.selectedIndex).text;
  lastSelectedForTag[currentElementList] = elementSelectList.selectedIndex;
  return chooseElementByName(selectedTag);
};

userManuallyClickedOnSelectListEntry = function() {
  return updateChosenItemBasedOnSelect();
};

addElementButton = function(idNumber, name) {
  var element;
  element = document.createElement("input");
  element.setAttribute("type", "button");
  element.setAttribute("value", name);
  element.setAttribute("name", idNumber);
  element.setAttribute("onclick", "chooseElementByName(this.value);");
  return document.getElementById("buttons-container").appendChild(element);
};

addTagButton = function(name, label) {
  var element;
  element = document.createElement("input");
  element.setAttribute("type", "button");
  element.setAttribute("value", label);
  element.setAttribute("name", name);
  element.setAttribute("onclick", "tagButtonPressed(this.name);");
  element.setAttribute("class", "myButton");
  return document.getElementById("buttons-container").appendChild(element);
};

currentElementList = null;

elementSelectList = document.getElementById("elementSelectList").options;

bringUpElementList = function(name) {
  var i, j, newOption, ref, ref1;
  if (currentElementList === name) {
    return;
  }
  for (i = j = 0, ref = elementSelectList.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    elementSelectList.remove(0);
  }
  ref1 = elementsInTag[name];
  for (i of ref1) {
    newOption = document.createElement("option");
    newOption.text = i;
    elementSelectList.add(newOption);
  }
  if (lastSelectedForTag[name] != null) {
    elementSelectList.selectedIndex = lastSelectedForTag[name];
  }
  currentElementList = name;
  if (elementSelectList.selectedIndex === -1) {
    elementSelectList.selectedIndex = 0;
  }
  return updateChosenItemBasedOnSelect();
};

tagButtonPressed = function(name) {
  return bringUpElementList(name);
};

initUI = function() {
  var i, j, ref;
  if (DEBUG_UI) {
    for (i = j = 0, ref = elementName.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      addElementButton(i, elementName[i]);
    }
  }
  addTagButton("gas", "gases [1]");
  addTagButton("liquid", "liquids [2]");
  addTagButton("solid", "solids [3]");
  return addTagButton("flammable", "flammables [4]");
};

currentlyOpenModal = null;

keyboardMouseHelpModal = document.getElementById('keyboardMouseHelpModal');

openKeyboardMouseHelpModal = function() {
  keyboardMouseHelpModal.style.display = 'block';
  currentlyOpenModal = keyboardMouseHelpModal;
};

dismissNavigationHelpModal = function() {
  return dismissModal(keyboardMouseHelpModal);
};

examplesModal = document.getElementById('examplesModal');

openExamplesModal = function() {
  examplesModal.style.display = 'block';
  currentlyOpenModal = examplesModal;
  document.getElementById("examplesSelectList").focus();
};

startSelectedExample = function() {
  var examplesSelectList;
  examplesSelectList = document.getElementById("examplesSelectList").options;
  return window[examplesSelectList.item(examplesSelectList.selectedIndex).value].call();
};

dismissExamplesModal = function() {
  return dismissModal(examplesModal);
};

startSelectedExampleAndDismissExamplesModal = function() {
  startSelectedExample();
  return dismissExamplesModal();
};

window.onclick = function(event) {
  if (event.target === keyboardMouseHelpModal || event.target === examplesModal) {
    return dismissModal(event.target);
  }
};

dismissModal = function(whichModal) {
  whichModal.style.display = 'none';
  return currentlyOpenModal = null;
};

elementColor = newArray(elementsCount, null);

elementDensity = newArray(elementsCount, 0.0);

reactionOptions = newArray(elementsCount, elementsCount, -1);

neighborProbability = newArray(elementsCount, elementsCount, 0.0);

transmutationProbability = newArray(elementsCount, 0.0);

transmutationTo = newArray(elementsCount, 0);

verticalMotionProbability = newArray(elementsCount, 0.0);

horizontalMotionProbability = newArray(elementsCount, 0.0);

elementName = newArray(elementsCount, "");

uElementsColors = new Int32Array(new Array(elementsCount * 3).fill(0));

tags = new Set;

elementsInTag = {};

initMainDataStructures = function(elementColor, elementDensity, reactionOptions, neighborProbability, transmutationProbability, verticalMotionProbability, horizontalMotionProbability, elementName) {
  var eachTag, i, j, k, key, len, movingElement, neighborArg1, neighborArg2, neighborArg3, neighborArg4, ref, ref1, results, transmutatingElement, value;
  i = 0;
  for (key in elements) {
    if (!hasProp.call(elements, key)) continue;
    value = elements[key];
    elementName[i] = key;
    elementColor[i] = value.rgb;
    elementDensity[i] = value.density;
    if (value.tags != null) {
      ref = value.tags;
      for (j = 0, len = ref.length; j < len; j++) {
        eachTag = ref[j];
        tags.add(eachTag);
        if (elementsInTag[eachTag] == null) {
          elementsInTag[eachTag] = new Set;
        }
        elementsInTag[eachTag].add(key);
      }
    }
    if (i > 0) {
      uElementsColors[3 * (i - 1) + 0] = elementColor[i][0];
      uElementsColors[3 * (i - 1) + 1] = elementColor[i][1];
      uElementsColors[3 * (i - 1) + 2] = elementColor[i][2];
    }
    i++;
  }
  results = [];
  for (key in elements) {
    if (!hasProp.call(elements, key)) continue;
    value = elements[key];
    if (value.nextToThese != null) {
      neighborArg1 = elementName.indexOf(key);
      for (i = k = 0, ref1 = value.nextToThese.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
        neighborArg2 = elementName.indexOf(value.nextToThese[i]);
        neighborArg3 = elementName.indexOf(value.becomesRespectivelyThis[i]);
        neighborArg4 = value.withRespectiveProbs[i];
        reactionOptions[neighborArg1][neighborArg2] = neighborArg3;
        neighborProbability[neighborArg1][neighborArg2] = neighborArg4;
      }
    }
    if (value.transmutatesTo != null) {
      transmutatingElement = elementName.indexOf(key);
      transmutationProbability[transmutatingElement] = value.transmutationProb;
      transmutationTo[transmutatingElement] = elementName.indexOf(value.transmutatesTo);
    }
    if (value.verticalMoveProb != null) {
      movingElement = elementName.indexOf(key);
      verticalMotionProbability[movingElement] = value.verticalMoveProb;
      results.push(horizontalMotionProbability[movingElement] = value.horizontalMoveProb);
    } else {
      results.push(void 0);
    }
  }
  return results;
};

initMainDataStructures(elementColor, elementDensity, reactionOptions, neighborProbability, transmutationProbability, verticalMotionProbability, horizontalMotionProbability, elementName);

initUI();

modelView = null;

cam = null;

projection = null;

programObjectFaces = null;

programObjectRects = null;

programObjectLines = null;

rectBuffer = null;

faceBuffer = null;

lineBuffer = null;

createProgramObject = function(curContext, vetexShaderSource, fragmentShaderSource) {
  var fragmentShaderObject, programObject, vertexShaderObject;
  vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER);
  curContext.shaderSource(vertexShaderObject, vetexShaderSource);
  curContext.compileShader(vertexShaderObject);
  if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {
    throw curContext.getShaderInfoLog(vertexShaderObject);
  }
  fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER);
  curContext.shaderSource(fragmentShaderObject, fragmentShaderSource);
  curContext.compileShader(fragmentShaderObject);
  if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {
    throw curContext.getShaderInfoLog(fragmentShaderObject);
  }
  programObject = curContext.createProgram();
  curContext.attachShader(programObject, vertexShaderObject);
  curContext.attachShader(programObject, fragmentShaderObject);
  curContext.linkProgram(programObject);
  if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {
    throw 'Error linking shaders.';
  }
  return programObject;
};

uniformMatrix = function(cacheId, programObj, varName, transpose, matrix) {
  var varLocation;
  varLocation = curContextCache.locations[cacheId];
  if (varLocation == null) {
    varLocation = curContext.getUniformLocation(programObj, varName);
    curContextCache.locations[cacheId] = varLocation;
  }
  if (varLocation !== -1) {
    if (matrix.length === 16) {
      curContext.uniformMatrix4fv(varLocation, transpose, matrix);
    } else if (matrix.length === 9) {
      curContext.uniformMatrix3fv(varLocation, transpose, matrix);
    } else {
      curContext.uniformMatrix2fv(varLocation, transpose, matrix);
    }
  }
};

smoothed = [0, 0, 0, 0, 0];

smoothing = [200, 200, 70, 50, 50];

smoothThreshold = [0.1, 0.1, 0.1, 0, 0];

startingTime = new Date;

lastUpdate = [startingTime, startingTime, startingTime, startingTime, startingTime, startingTime];

smoothedValue = function(newValue, whichVariable) {
  var elapsedTime, now;
  now = new Date;
  elapsedTime = now - lastUpdate[whichVariable];
  if (Math.abs(smoothed[whichVariable]) < smoothThreshold[whichVariable]) {
    smoothed[whichVariable] = newValue;
  } else {
    smoothed[whichVariable] += elapsedTime * (newValue - smoothed[whichVariable]) / smoothing[whichVariable];
  }
  lastUpdate[whichVariable] = now;
  return smoothed[whichVariable];
};

smoothed_FWD = function(newValue) {
  return smoothedValue(newValue, 0);
};

smoothed_SIDE = function(newValue) {
  return smoothedValue(newValue, 1);
};

smoothed_UP = function(newValue) {
  return smoothedValue(newValue, 2);
};

smoothed_YAW = function(newValue) {
  return smoothedValue(newValue, 3);
};

smoothed_PITCH = function(newValue) {
  return smoothedValue(newValue, 4);
};

getGLContext = function(canvas) {
  var ctxNames, eachCtxName, gl, j, len;
  ctxNames = ['experimental-webgl', 'webgl', 'webkit-3d'];
  for (j = 0, len = ctxNames.length; j < len; j++) {
    eachCtxName = ctxNames[j];
    gl = canvas.getContext(eachCtxName, {
      antialias: false,
      preserveDrawingBuffer: true
    });
    if (gl) {
      break;
    }
  }
  return gl;
};

curContext = null;

curContextCache = {
  attributes: {},
  locations: {}
};

rectVerts = new Float32Array([0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0]);

VERTS_PER_FACE = 6;

MAX_FACES_PER_BATCH = 100;

faceVerts = new Float32Array(Array.from(Array(MAX_FACES_PER_BATCH * VERTS_PER_FACE), (function(_this) {
  return function(e, i) {
    return i;
  };
})(this)));

size = function(aWidth, aHeight) {
  canvasElement.width = aWidth || 100;
  canvasElement.height = aHeight || 100;
  curContext = getGLContext(canvasElement);
  if (!curContext) {
    throw 'WebGL context is not supported on this browser.';
  }
  curContext.viewport(0, 0, canvasElement.width, canvasElement.height);
  curContext.enable(curContext.DEPTH_TEST);
  curContext.enable(curContext.BLEND);
  curContext.blendFunc(curContext.SRC_ALPHA, curContext.ONE_MINUS_SRC_ALPHA);
  programObjectLines = createProgramObject(curContext, vertexShaderSrcLines, fragmentShaderSrcLines);
  programObjectRects = createProgramObject(curContext, vertexShaderSrcRects, fragmentShaderSrcRects);
  curContext.useProgram(programObjectRects);
  rectBuffer = curContext.createBuffer();
  curContext.bindBuffer(curContext.ARRAY_BUFFER, rectBuffer);
  curContext.bufferData(curContext.ARRAY_BUFFER, rectVerts, curContext.STATIC_DRAW);
  programObjectFaces = createProgramObject(curContext, vertexShaderSrcFaces, fragmentShaderSrcFaces);
  curContext.useProgram(programObjectFaces);
  faceBuffer = curContext.createBuffer();
  curContext.bindBuffer(curContext.ARRAY_BUFFER, faceBuffer);
  curContext.bufferData(curContext.ARRAY_BUFFER, faceVerts, curContext.STATIC_DRAW);
  lineBuffer = curContext.createBuffer();
  cam = new Matrix4x4;
  modelView = new Matrix4x4;
  projection = new Matrix4x4;
  camera();
  perspective();
  if (canvasElement.style.length > 0) {
    canvasElement.style.removeProperty('width');
    canvasElement.style.removeProperty('height');
  }
  canvasElement.width = aWidth || 100;
  return canvasElement.height = aHeight || 100;
};

Vec3 = (function() {
  Vec3.prototype.x = 0;

  Vec3.prototype.y = 0;

  Vec3.prototype.z = 0;

  function Vec3(x3, y3, z3) {
    this.x = x3 != null ? x3 : 0;
    this.y = y3 != null ? y3 : 0;
    this.z = z3 != null ? z3 : 0;
  }

  Vec3.prototype.mag = function() {
    var x, y, z;
    x = this.x;
    y = this.y;
    z = this.z;
    return Math.sqrt(x * x + y * y + z * z);
  };

  Vec3.prototype.div = function(v) {
    if (typeof v === 'number') {
      this.x /= v;
      this.y /= v;
      this.z /= v;
    } else {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
    }
  };

  Vec3.prototype.cross = function(v) {
    var x, y, z;
    x = this.x;
    y = this.y;
    z = this.z;
    return new Vec3(y * v.z - (v.y * z), z * v.x - (v.z * x), x * v.y - (v.x * y));
  };

  Vec3.prototype.normalize = function() {
    var m;
    m = this.mag();
    if (m > 0) {
      this.div(m);
    }
  };

  return Vec3;

})();

Matrix4x4 = (function() {
  function Matrix4x4() {
    this.reset();
    return;
  }

  Matrix4x4.prototype.set = function() {
    if (arguments.length === 16) {
      this.elements = Array.prototype.slice.call(arguments);
    } else if (arguments.length === 1 && arguments[0] instanceof Matrix4x4) {
      this.elements = arguments[0].array();
    } else if (arguments.length === 1 && arguments[0] instanceof Array) {
      this.elements = arguments[0].slice();
    }
  };

  Matrix4x4.prototype.get = function() {
    var outgoing;
    outgoing = new Matrix4x4;
    outgoing.set(this.elements);
    return outgoing;
  };

  Matrix4x4.prototype.reset = function() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  };

  Matrix4x4.prototype.array = function() {
    return this.elements.slice();
  };

  Matrix4x4.prototype.translate = function(tx, ty, tz) {
    if (tx instanceof Array) {
      ty = tx[1];
      tz = tx[2];
      tx = tx[0];
    }
    this.elements[3] += tx * this.elements[0] + ty * this.elements[1] + tz * this.elements[2];
    this.elements[7] += tx * this.elements[4] + ty * this.elements[5] + tz * this.elements[6];
    this.elements[11] += tx * this.elements[8] + ty * this.elements[9] + tz * this.elements[10];
    this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];
  };

  Matrix4x4.prototype.transpose = function() {
    var temp;
    temp = this.elements[4];
    this.elements[4] = this.elements[1];
    this.elements[1] = temp;
    temp = this.elements[8];
    this.elements[8] = this.elements[2];
    this.elements[2] = temp;
    temp = this.elements[6];
    this.elements[6] = this.elements[9];
    this.elements[9] = temp;
    temp = this.elements[3];
    this.elements[3] = this.elements[12];
    this.elements[12] = temp;
    temp = this.elements[7];
    this.elements[7] = this.elements[13];
    this.elements[13] = temp;
    temp = this.elements[11];
    this.elements[11] = this.elements[14];
    this.elements[14] = temp;
  };

  Matrix4x4.prototype.apply = function() {
    var col, e, result, row, source;
    source = void 0;
    if (arguments.length === 1 && arguments[0] instanceof Matrix4x4) {
      source = arguments[0].array();
    } else if (arguments.length === 16) {
      source = Array.prototype.slice.call(arguments);
    } else if (arguments.length === 1 && arguments[0] instanceof Array) {
      source = arguments[0];
    }
    result = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    e = 0;
    row = 0;
    while (row < 4) {
      col = 0;
      while (col < 4) {
        result[e] += this.elements[row * 4 + 0] * source[col + 0] + this.elements[row * 4 + 1] * source[col + 4] + this.elements[row * 4 + 2] * source[col + 8] + this.elements[row * 4 + 3] * source[col + 12];
        col++;
        e++;
      }
      row++;
    }
    this.elements = result.slice();
  };

  Matrix4x4.prototype.scale = function(sx, sy, sz) {
    if (sx && !sy && !sz) {
      sy = sz = sx;
    } else if (sx && sy && !sz) {
      sz = 1;
    }
    if (sx && sy && sz) {
      this.elements[0] *= sx;
      this.elements[1] *= sy;
      this.elements[2] *= sz;
      this.elements[4] *= sx;
      this.elements[5] *= sy;
      this.elements[6] *= sz;
      this.elements[8] *= sx;
      this.elements[9] *= sy;
      this.elements[10] *= sz;
      this.elements[12] *= sx;
      this.elements[13] *= sy;
      this.elements[14] *= sz;
    }
  };

  return Matrix4x4;

})();

cameraFOV = 60 * (Math.PI / 180);

cameraX = 0.0;

cameraY = 0.0;

cameraZ = 0.0;

cameraDirectionX = 0.0;

cameraDirectionY = 0.0;

cameraDirectionZ = 0.0;

pitch = 0;

yaw = 0;

cameraX = canvasWidth / 2;

cameraY = canvasHeight / 2;

cameraZ = cameraY / Math.tan(cameraFOV / 2);


/**
 * Sets the position of the camera through setting the eye position, the center of the scene, and which axis is facing
 * upward. Moving the eye position and the direction it is pointing (the center of the scene) allows the images to be
 * seen from different angles. The version without any parameters sets the camera to the default position, pointing to
 * the center of the display window with the Y axis as up. The default values are camera(width/2.0, height/2.0,
 * (height/2.0) / tan(PI*60.0 / 360.0), width/2.0, height/2.0, 0, 0, 1, 0). This function is similar to gluLookAt()
 * in OpenGL, but it first clears the current camera settings.
 *
 * @param {float} eyeX    x-coordinate for the eye
 * @param {float} eyeY    y-coordinate for the eye
 * @param {float} eyeZ    z-coordinate for the eye
 * @param {float} centerX x-coordinate for the center of the scene
 * @param {float} centerY y-coordinate for the center of the scene
 * @param {float} centerZ z-coordinate for the center of the scene
 * @param {float} upX     usually 0.0, 1.0, -1.0
 * @param {float} upY     usually 0.0, 1.0, -1.0
 * @param {float} upZ     usually 0.0, 1.0, -1.0
 *
 * @see beginCamera
 * @see endCamera
 * @see frustum
 */

camera = function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
  var x, xX, xY, xZ, y, yX, yY, yZ, z, zX, zY, zZ;
  if (eyeX == null) {
    eyeX = cameraX;
    eyeY = cameraY;
    eyeZ = cameraZ;
    centerX = cameraX;
    centerY = cameraY;
    centerZ = 0;
    upX = 0;
    upY = 1;
    upZ = 0;
  }
  z = new Vec3(eyeX - centerX, eyeY - centerY, eyeZ - centerZ);
  y = new Vec3(upX, upY, upZ);
  z.normalize();
  x = y.cross(z);
  y = z.cross(x);
  x.normalize();
  y.normalize();
  xX = x.x;
  xY = x.y;
  xZ = x.z;
  yX = y.x;
  yY = y.y;
  yZ = y.z;
  zX = z.x;
  zY = z.y;
  zZ = z.z;
  cam.set(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);
  cam.translate(-eyeX, -eyeY, -eyeZ);
  return modelView.set(cam);
};

fromCameraCalculateMoveOf = function(forwardHowMuch, leftHowMuch, upHowMuch) {
  var tmpX, tmpY, tmpZ;
  tmpX = Math.cos(yaw) * forwardHowMuch + Math.sin(yaw) * leftHowMuch;
  tmpY = Math.cos(yaw) * leftHowMuch - Math.sin(yaw) * forwardHowMuch;
  tmpZ = Math.sin(pitch) * forwardHowMuch + Math.cos(pitch) * upHowMuch;
  return [cameraX + tmpX, cameraY + tmpY, cameraZ + tmpZ];
};

updateCamera = function(cameraMoveForward, cameraMoveSide, cameraMoveUp) {
  var ref, ref1, tiltLimit;
  tiltLimit = 0;
  if (pitch > Math.PI / 2 - tiltLimit) {
    pitch = Math.PI / 2 - tiltLimit;
  }
  if (pitch < -Math.PI / 2 + tiltLimit) {
    pitch = -Math.PI / 2 + tiltLimit;
  }
  while (yaw > Math.PI * 2) {
    yaw = yaw - Math.PI * 2;
  }
  while (yaw < -Math.PI * 2) {
    yaw = yaw + Math.PI * 2;
  }
  ref = fromCameraCalculateMoveOf(cameraMoveForward, cameraMoveSide, cameraMoveUp * 2), cameraX = ref[0], cameraY = ref[1], cameraZ = ref[2];
  return ref1 = fromCameraCalculateMoveOf(1, 0, 0), cameraDirectionX = ref1[0], cameraDirectionY = ref1[1], cameraDirectionZ = ref1[2], ref1;
};

colorModeA = 255;

colorModeX = 255;

colorModeY = 255;

colorModeZ = 255;

ALPHA_MASK = 0xff000000;

RED_MASK = 0x00ff0000;

GREEN_MASK = 0x0000ff00;

BLUE_MASK = 0x000000ff;


/**
* Creates colors for storing in variables of the color datatype. The parameters are
* interpreted as RGB or HSB values depending on the current colorMode(). The default
* mode is RGB values from 0 to 255 and therefore, the function call color(255, 204, 0)
* will return a bright yellow color. More about how colors are stored can be found in
* the reference for the color datatype.
*
* @param {int|float} aValue1        red or hue or grey values relative to the current color range.
* Also can be color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)
* @param {int|float} aValue2        green or saturation values relative to the current color range
* @param {int|float} aValue3        blue or brightness values relative to the current color range
* @param {int|float} aValue4        relative to current color range. Represents alpha
*
* @returns {color} the color
*
* @see colorMode
 */

colorIntFromRGB = function(aValue1, aValue2, aValue3) {
  var a, b, g, r;
  r = void 0;
  g = void 0;
  b = void 0;
  a = void 0;
  r = Math.round(255 * aValue1 / colorModeX);
  g = Math.round(255 * aValue2 / colorModeY);
  b = Math.round(255 * aValue3 / colorModeZ);
  a = Math.round(255 * 255 / colorModeA);
  r = r < 0 ? 0 : r;
  g = g < 0 ? 0 : g;
  b = b < 0 ? 0 : b;
  a = a < 0 ? 0 : a;
  r = r > 255 ? 255 : r;
  g = g > 255 ? 255 : g;
  b = b > 255 ? 255 : b;
  a = a > 255 ? 255 : a;
  return a << 24 & ALPHA_MASK | r << 16 & RED_MASK | g << 8 & GREEN_MASK | b & BLUE_MASK;
};

colorIntToGLArray = function(colorInt) {
  return [((colorInt & RED_MASK) >>> 16) / 255, ((colorInt & GREEN_MASK) >>> 8) / 255, (colorInt & BLUE_MASK) / 255, ((colorInt & ALPHA_MASK) >>> 24) / 255];
};

currentFillColor = 0xFFFFFFFF;

doFill = true;

fillStyle = [1.0, 1.0, 1.0, 1.0];

fill = function() {
  var color;
  color = colorIntFromRGB.apply(this, arguments);
  if (color === currentFillColor && doFill) {
    return;
  }
  doFill = true;
  currentFillColor = color;
  return fillStyle = colorIntToGLArray(currentFillColor);
};

noFill = function() {
  return doFill = false;
};

currentStrokeColor = 0xFF000000;

doStroke = true;

strokeStyle = [0.0, 0.0, 0.0, 1.0];

stroke = function() {
  var color;
  color = colorIntFromRGB.apply(this, arguments);
  if (color === currentStrokeColor && doStroke) {
    return;
  }
  doStroke = true;
  currentStrokeColor = color;
  strokeStyle = colorIntToGLArray(currentStrokeColor);
};

noStroke = function() {
  doStroke = false;
};

background = function(arg1, arg2, arg3) {
  var backgroundObj, c;
  if (arg1 instanceof Array) {
    backgroundObj = colorIntFromRGB(arg1[0], arg1[1], arg1[2]);
  } else {
    backgroundObj = colorIntFromRGB(arg1, arg2, arg3);
  }
  c = colorIntToGLArray(backgroundObj);
  curContext.clearColor(c[0], c[1], c[2], c[3]);
  curContext.clear(curContext.COLOR_BUFFER_BIT | curContext.DEPTH_BUFFER_BIT);
  return curContext.disable(curContext.CULL_FACE);
};

vertexShaderSrcLines = "varying vec4 vFaceColor;\nattribute vec3 aVertex;\nuniform vec4 uColor;\nuniform mat4 uView;\nuniform mat4 uProjection;\nvoid main(void) {\n  vFaceColor = uColor;\n  gl_Position = uProjection * uView * vec4(aVertex, 1.0);\n}";

fragmentShaderSrcLines = "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vFaceColor;\nvoid main(void){\n  gl_FragColor = vFaceColor;\n}";

vertexShaderSrcRects = "varying vec4 vFaceColor;\nattribute vec3 aVertex;\n\nuniform vec4 uColor;\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nvoid main(void) {\n  vFaceColor = uColor;\n  gl_Position = uProjection * uView * uModel * vec4( aVertex, 1.0 );\n}";

fragmentShaderSrcRects = "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vFaceColor;\n\n// when a texture is used, the fill color is ignored\nvoid main(void){\n gl_FragColor = vFaceColor;\n}";

vertexShaderSrcFaces = "varying vec3 vFaceColor;\n\nattribute float aVertex;\n\nuniform mat4  uView;\nuniform mat4  uProjection;\nuniform ivec2 uElementIDAndSide[" + MAX_FACES_PER_BATCH + "];\nuniform ivec3 uXYZ[" + MAX_FACES_PER_BATCH + "];\nuniform ivec3 uElementsColors[" + elementsCount + "];\n\nvoid main(void) {\n  vec4 theVertex;\n  highp int vertexNumberInFace = int(mod(aVertex,6.0));\n  highp int faceNumberInt = int(aVertex/6.0);\n  highp int aElementIDInt = uElementIDAndSide[faceNumberInt][0];\n  highp int aSideInt = uElementIDAndSide[faceNumberInt][1];\n\n  highp int tx = uXYZ[faceNumberInt][0];\n  highp int ty = uXYZ[faceNumberInt][1];\n  highp int tz = uXYZ[faceNumberInt][2];\n\n\n  vFaceColor[0] = float(uElementsColors[aElementIDInt-1][0])/255.0;\n  vFaceColor[1] = float(uElementsColors[aElementIDInt-1][1])/255.0;\n  vFaceColor[2] = float(uElementsColors[aElementIDInt-1][2])/255.0;\n\n  // give a different shade to the sides so there is some\n  // basic sense of illumination\n  // right or left\n  if (aSideInt == 0 || aSideInt == 1) {\n    vFaceColor -= 60.0/255.0;\n  }\n  // front or back\n  else if (aSideInt == 4 || aSideInt == 5) {\n    vFaceColor -= 30.0/255.0;\n  }\n  // bottom\n  else if (aSideInt == 2) {\n    vFaceColor -= 90.0/255.0;\n  }\n  //\n  //\n\n\n  //FACE_FRONT = 4.0 FACE_BACK = 5.0\n  if (aSideInt == 4 || aSideInt == 5) {\n    if (vertexNumberInFace == 0 ) {\n      theVertex = vec4( tx+ 0, ty+ 0, tz+ 0, 1.0 );\n    }\n    else if (vertexNumberInFace == 1 ) {\n      theVertex = vec4( tx+ 1, ty+ 0, tz+ 0, 1.0 );\n    }\n    else if (vertexNumberInFace == 2 ) {\n      theVertex = vec4( tx+ 1, ty+ 1, tz+ 0, 1.0 );\n    }\n    else if (vertexNumberInFace == 3 ) {\n      theVertex = vec4( tx+ 1, ty+ 1, tz+ 0, 1.0 );\n    }\n    else if (vertexNumberInFace == 4 ) {\n      theVertex = vec4( tx+ 0, ty+ 1, tz+ 0, 1.0 );\n    }\n    else if (vertexNumberInFace == 5 ) {\n      theVertex = vec4( tx+ 0, ty+ 0, tz+ 0, 1.0 );\n    }\n  }\n\n\n  //FACE_TOP = 3.0 FACE_BOTTOM = 2.0\n  if (aSideInt == 3 || aSideInt == 2 ) {\n    if (vertexNumberInFace == 0 ) {\n      theVertex = vec4( tx+ 0, ty+ 0, tz+ 0, 1.0 );\n    }\n    else if (vertexNumberInFace == 1 ) {\n      theVertex = vec4( tx+ 1, ty+ 0, tz+ 0, 1.0 );\n    }\n    else if (vertexNumberInFace == 2 ) {\n      theVertex = vec4( tx+ 1, ty+ 0, tz+ 1, 1.0 );\n    }\n    else if (vertexNumberInFace == 3 ) {\n      theVertex = vec4( tx+ 1, ty+ 0, tz+ 1, 1.0 );\n    }\n    else if (vertexNumberInFace == 4 ) {\n      theVertex = vec4( tx+ 0, ty+ 0, tz+ +1, 1.0 );\n    }\n    else if (vertexNumberInFace == 5 ) {\n      theVertex = vec4( tx+ 0, ty+ 0, tz+ 0, 1.0 );\n    }\n  }\n\n\n  //FACE_LEFT = 1 FACE_RIGHT = 0\n  if (aSideInt == 1 || aSideInt == 0 ) {\n    if (vertexNumberInFace == 0 ) {\n      theVertex = vec4( tx+ 0, ty+ 0, tz+ 0, 1.0 );\n    }\n    else if (vertexNumberInFace == 1 ) {\n      theVertex = vec4( tx+ 0, ty+ 0, tz- 1, 1.0 );\n    }\n    else if (vertexNumberInFace == 2 ) {\n      theVertex = vec4( tx+ 0, ty+ 1, tz - 1, 1.0 );\n    }\n    else if (vertexNumberInFace == 3 ) {\n      theVertex = vec4( tx+ 0, ty+ 1, tz - 1, 1.0 );\n    }\n    else if (vertexNumberInFace == 4 ) {\n      theVertex = vec4( tx+ 0, ty+ 1, tz+ 0, 1.0 );\n    }\n    else if (vertexNumberInFace == 5 ) {\n      theVertex = vec4( tx+ 0, ty+ 0, tz+ 0, 1.0 );\n    }\n  }\n\n  gl_Position = uProjection * uView * theVertex;\n}";

fragmentShaderSrcFaces = "precision mediump float;\n\nvarying vec3 vFaceColor;\n\nvoid main(void){\n gl_FragColor = vec4(vFaceColor,1.0);\n}";


/*
 * Sets a uniform variable in a program object to a particular
 * value. Before calling this function, ensure the correct
 * program object has been installed as part of the current
 * rendering state by calling useProgram.
 *
 * On some systems, if the variable exists in the shader but isn't used,
 * the compiler will optimize it out and this function will fail.
 *
 * @param {String} cacheId
 * @param {WebGLProgram} programObj program object returned from
 * createProgramObject
 * @param {String} varName the name of the variable in the shader
 * @param {float | Array} varValue either a scalar value or an Array
 *
 * @returns none
 *
 * @see uniformi
 * @see uniformMatrix
 */

uniformf = function(cacheId, programObj, varName, varValue, eachVectorLength) {
  var varLocation;
  varLocation = curContextCache.locations[cacheId];
  if (varLocation == null) {
    varLocation = curContext.getUniformLocation(programObj, varName);
    curContextCache.locations[cacheId] = varLocation;
  }
  if (varLocation !== null) {
    if (eachVectorLength === 4) {
      curContext.uniform4fv(varLocation, varValue);
    } else if (eachVectorLength === 3) {
      curContext.uniform3fv(varLocation, varValue);
    } else if (eachVectorLength === 2) {
      curContext.uniform2fv(varLocation, varValue);
    } else {
      curContext.uniform1f(varLocation, varValue);
    }
  }
};


/**
 * Sets a uniform int or int array in a program object to a particular
 * value. Before calling this function, ensure the correct
 * program object has been installed as part of the current
 * rendering state.
 *
 * On some systems, if the variable exists in the shader but isn't used,
 * the compiler will optimize it out and this function will fail.
 *
 * @param {String} cacheId
 * @param {WebGLProgram} programObj program object returned from
 * createProgramObject
 * @param {String} varName the name of the variable in the shader
 * @param {int | Array} varValue either a scalar value or an Array
 *
 * @returns none
 *
 * @see uniformf
 * @see uniformMatrix
 */

uniformi = function(cacheId, programObj, varName, varValue, eachVectorLength) {
  var varLocation;
  varLocation = curContextCache.locations[cacheId];
  if (varLocation == null) {
    varLocation = curContext.getUniformLocation(programObj, varName);
    curContextCache.locations[cacheId] = varLocation;
  }
  if (varLocation !== null) {
    if (eachVectorLength === 4) {
      curContext.uniform4iv(varLocation, varValue);
    } else if (eachVectorLength === 3) {
      curContext.uniform3iv(varLocation, varValue);
    } else if (eachVectorLength === 2) {
      curContext.uniform2iv(varLocation, varValue);
    } else {
      curContext.uniform1i(varLocation, varValue);
    }
  }
};

vertexAttribPointer = function(cacheId, programObj, varName, size, VBO) {
  var varLocation;
  varLocation = curContextCache.attributes[cacheId];
  if (varLocation == null) {
    varLocation = curContext.getAttribLocation(programObj, varName);
    curContextCache.attributes[cacheId] = varLocation;
  }
  if (varLocation !== -1) {
    curContext.bindBuffer(curContext.ARRAY_BUFFER, VBO);
    curContext.vertexAttribPointer(varLocation, size, curContext.FLOAT, false, 0, 0);
    curContext.enableVertexAttribArray(varLocation);
  }
};

perspective = function(fov, aspect, near, far) {
  var cameraAspect, cameraFar, cameraNear, xMax, xMin, yMax, yMin;
  if (arguments.length === 0) {
    cameraY = canvasElement.height / 2;
    cameraZ = cameraY / Math.tan(cameraFOV / 2);
    cameraNear = cameraZ / 10;
    cameraFar = cameraZ * 10;
    cameraAspect = canvasWidth / canvasHeight;
    fov = cameraFOV;
    aspect = cameraAspect;
    near = cameraNear;
    far = cameraFar;
  }
  yMax = void 0;
  yMin = void 0;
  xMax = void 0;
  xMin = void 0;
  yMax = near * Math.tan(fov / 2);
  yMin = -yMax;
  xMax = yMax * aspect;
  xMin = yMin * aspect;
  return frustum(xMin, xMax, yMin, yMax, near, far);
};

frustum = function(left, right, bottom, top, near, far) {
  var frustumMode, proj;
  frustumMode = true;
  projection = new Matrix4x4;
  projection.set(2 * near / (right - left), 0, (right + left) / (right - left), 0, 0, 2 * near / (top - bottom), (top + bottom) / (top - bottom), 0, 0, 0, -(far + near) / (far - near), -(2 * far * near) / (far - near), 0, 0, -1, 0);
  proj = new Matrix4x4;
  proj.set(projection);
  proj.transpose();
  curContext.useProgram(programObjectLines);
  uniformMatrix('projectionLine', programObjectLines, 'uProjection', false, proj.array());
  curContext.useProgram(programObjectRects);
  uniformMatrix('projectionRect', programObjectRects, 'uProjection', false, proj.array());
  curContext.useProgram(programObjectFaces);
  return uniformMatrix('projectionFace', programObjectFaces, 'uProjection', false, proj.array());
};

line = function(x1, y1, z1, x2, y2, z2) {
  var lineVerts, view;
  lineVerts = [x1, y1, z1, x2, y2, z2];
  view = new Matrix4x4;
  view.apply(modelView.array());
  view.transpose();
  if (doStroke) {
    curContext.useProgram(programObjectLines);
    uniformMatrix('uView2d', programObjectLines, 'uView', false, view.array());
    uniformf('uColor2d', programObjectLines, 'uColor', strokeStyle, 4);
    vertexAttribPointer('aVertex2d', programObjectLines, 'aVertex', 3, lineBuffer);
    curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(lineVerts), curContext.STREAM_DRAW);
    curContext.drawArrays(curContext.LINES, 0, 2);
  }
};

dottedLine = function(segments, extremeSegments, x1, y1, z1, x2, y2, z2) {
  var i, j, newDotX, newDotY, newDotZ, prevDotX, prevDotY, prevDotZ, ref;
  prevDotX = x1;
  prevDotY = y1;
  prevDotZ = z1;
  for (i = j = 0, ref = segments; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    newDotX = x1 + i * (x2 - x1) / segments;
    newDotY = y1 + i * (y2 - y1) / segments;
    newDotZ = z1 + i * (z2 - z1) / segments;
    if (i % 2 || i < extremeSegments || i > segments - extremeSegments) {
      line(prevDotX, prevDotY, prevDotZ, newDotX, newDotY, newDotZ);
    }
    prevDotX = newDotX;
    prevDotY = newDotY;
    prevDotZ = newDotZ;
  }
  line(prevDotX, prevDotY, prevDotZ, x2, y2, z2);
};

containerBox = function(origX, origY, origZ, sizeX, sizeY, sizeZ) {
  var extremeSegments, segments;
  fill(10, 10, 10);
  rect(origX + 1, origY + 1, origZ, sizeX - 2, sizeY - 2);
  noFill();
  rect(origX, origY, origZ, sizeX, sizeY);
  if (doStroke) {
    noFill();
    segments = 100;
    extremeSegments = 10;
    if (cameraZ < (origZ + sizeZ) || !(cameraX < 0)) {
      dottedLine(segments, extremeSegments, origX, origY, origZ + sizeZ, origX, origY + sizeY, origZ + sizeZ);
    }
    if (cameraZ < (origZ + sizeZ) || !(cameraX > origX + sizeX)) {
      dottedLine(segments, extremeSegments, origX + sizeX, origY, origZ + sizeZ, origX + sizeX, origY + sizeY, origZ + sizeZ);
    }
    if (cameraZ < (origZ + sizeZ) || !(cameraY > origY + sizeY)) {
      dottedLine(segments, extremeSegments, origX, origY + sizeY, origZ + sizeZ, origX + sizeX, origY + sizeY, origZ + sizeZ);
    }
    if (cameraZ < (origZ + sizeZ) || !(cameraY < 0)) {
      dottedLine(segments, extremeSegments, origX, origY, origZ + sizeZ, origX + sizeX, origY, origZ + sizeZ);
    }
    if (!(cameraX < 0 && cameraY < 0)) {
      dottedLine(segments, extremeSegments, origX, origY, origZ, origX, origY, origZ + sizeZ);
    }
    if (!(cameraX < 0 && cameraY > origY + sizeY)) {
      dottedLine(segments, extremeSegments, origX, origY + sizeY, origZ, origX, origY + sizeY, origZ + sizeZ);
    }
    if (!(cameraX > origX + sizeX && cameraY < 0)) {
      dottedLine(segments, extremeSegments, origX + sizeX, origY, origZ, origX + sizeX, origY, origZ + sizeZ);
    }
    if (!(cameraX > origX + sizeX && cameraY > origY + sizeY)) {
      return dottedLine(segments, extremeSegments, origX + sizeX, origY + sizeY, origZ, origX + sizeX, origY + sizeY, origZ + sizeZ);
    }
  }
};

boxDottedStroke = function(segments, origX, origY, origZ, sizeX, sizeY, sizeZ) {
  var extremeSegments;
  if (doStroke) {
    noFill();
    extremeSegments = 0;
    dottedLine(segments, extremeSegments, origX, origY, origZ, origX + sizeX, origY, origZ);
    dottedLine(segments, extremeSegments, origX, origY, origZ, origX, origY + sizeY, origZ);
    dottedLine(segments, extremeSegments, origX, origY + sizeY, origZ, origX + sizeX, origY + sizeY, origZ);
    dottedLine(segments, extremeSegments, origX + sizeX, origY, origZ, origX + sizeX, origY + sizeY, origZ);
    dottedLine(segments, extremeSegments, origX, origY, origZ + sizeZ, origX, origY + sizeY, origZ + sizeZ);
    dottedLine(segments, extremeSegments, origX + sizeX, origY, origZ + sizeZ, origX + sizeX, origY + sizeY, origZ + sizeZ);
    dottedLine(segments, extremeSegments, origX, origY + sizeY, origZ + sizeZ, origX + sizeX, origY + sizeY, origZ + sizeZ);
    dottedLine(segments, extremeSegments, origX, origY, origZ + sizeZ, origX + sizeX, origY, origZ + sizeZ);
    dottedLine(segments, extremeSegments, origX, origY, origZ, origX, origY, origZ + sizeZ);
    dottedLine(segments, extremeSegments, origX, origY + sizeY, origZ, origX, origY + sizeY, origZ + sizeZ);
    dottedLine(segments, extremeSegments, origX + sizeX, origY, origZ, origX + sizeX, origY, origZ + sizeZ);
    return dottedLine(segments, extremeSegments, origX + sizeX, origY + sizeY, origZ, origX + sizeX, origY + sizeY, origZ + sizeZ);
  }
};

boxStroke = function(origX, origY, origZ, sizeX, sizeY, sizeZ) {
  if (doStroke) {
    noFill();
    rect(origX, origY, origZ, sizeX, sizeY);
    rect(origX, origY, origZ + sizeZ, sizeX, sizeY);
    line(origX, origY, origZ, origX, origY, origZ + sizeZ);
    line(origX, origY + sizeY, origZ, origX, origY + sizeY, origZ + sizeZ);
    line(origX + sizeX, origY, origZ, origX + sizeX, origY, origZ + sizeZ);
    return line(origX + sizeX, origY + sizeY, origZ, origX + sizeX, origY + sizeY, origZ + sizeZ);
  }
};

rect = function(x, y, z, width, height) {
  var model, view;
  model = new Matrix4x4;
  model.translate(x, y, z);
  model.scale(width, height, 1);
  model.transpose();
  view = new Matrix4x4;
  view.apply(modelView.array());
  view.transpose();
  curContext.useProgram(programObjectRects);
  uniformMatrix('uModelRect', programObjectRects, 'uModel', false, model.array());
  uniformMatrix('uViewRect', programObjectRects, 'uView', false, view.array());
  if (doFill) {
    uniformf('colorRect', programObjectRects, 'uColor', fillStyle, 4);
  } else if (doStroke) {
    uniformf('colorRect', programObjectRects, 'uColor', strokeStyle, 4);
  }
  vertexAttribPointer('vertexRect', programObjectRects, 'aVertex', 3, rectBuffer);
  if (doFill) {
    curContext.drawArrays(curContext.TRIANGLE_FAN, 0, rectVerts.length / 3);
  } else if (doStroke) {
    curContext.drawArrays(curContext.LINE_LOOP, 0, rectVerts.length / 3);
  }
};

facesInBatchSoFar = 0;

uElementIDAndSide = new Int32Array(new Array(MAX_FACES_PER_BATCH * 2).fill(0));

XYZs = new Int32Array(new Array(MAX_FACES_PER_BATCH * 3).fill(0));

face = function(element, whichSide, x, y, z) {
  uElementIDAndSide[facesInBatchSoFar * 2] = element;
  uElementIDAndSide[facesInBatchSoFar * 2 + 1] = whichSide;
  XYZs[facesInBatchSoFar * 3] = x;
  XYZs[facesInBatchSoFar * 3 + 1] = y;
  XYZs[facesInBatchSoFar * 3 + 2] = z;
  facesInBatchSoFar++;
  if (facesInBatchSoFar === MAX_FACES_PER_BATCH) {
    this.flushFaces();
  }
};

flushFaces = function() {
  var i, view;
  if (facesInBatchSoFar === 0) {
    return;
  }
  view = new Matrix4x4;
  view.apply(modelView.array());
  view.transpose();
  curContext.useProgram(programObjectFaces);
  uniformMatrix('uViewFace', programObjectFaces, 'uView', false, view.array());
  uniformi('uElementIDAndSide', programObjectFaces, 'uElementIDAndSide', uElementIDAndSide, 2);
  uniformi('uXYZ', programObjectFaces, 'uXYZ', XYZs, 3);
  uniformi('uElementsColors', programObjectFaces, 'uElementsColors', uElementsColors, 3);
  vertexAttribPointer('vertexFace', programObjectFaces, 'aVertex', 1, faceBuffer);
  curContext.drawArrays(curContext.TRIANGLES, 0, facesInBatchSoFar * 6);
  i = 0;
  while (i < 2 * facesInBatchSoFar) {
    uElementIDAndSide[i] = 0;
    i++;
  }
  facesInBatchSoFar = 0;
};

render_t0 = 0;

render_tf = 0;

particlesReactions_t0 = 0;

particlesReactions_tf = 0;

particlesMotion_t0 = 0;

particlesMotion_tf = 0;

instrumentation_countParticles_t0 = 0;

instrumentation_countParticles_tf = 0;

last_fps_count_time = 0;

canvasWidth = 640;

canvasHeight = 640;

rayCastSlot = [0, 0, 0];

justInFrontOfRayCastSlot = [0, 0, 0];

particleAt = newArray(gridSizeX, gridSizeY, gridSizeZ, 0);

particleNextTickAt = newArray(gridSizeX, gridSizeY, gridSizeZ, 0);

pauseRendering = false;

pauseReactionsAndMotion = false;

FACE_RIGHT = 0;

FACE_LEFT = 1;

FACE_BOTTOM = 2;

FACE_TOP = 3;

FACE_FRONT = 4;

FACE_BACK = 5;

initCanvasWebGLAndCamera = function() {
  var fov;
  size(canvasWidth, canvasHeight);
  fov = Math.PI / 3.0;
  cameraZ = canvasHeight / 2.0 / Math.tan(fov / 2.0);
  perspective(fov, canvasWidth / canvasHeight, cameraZ / 105.0, cameraZ * 15.0);
  cameraX = -32;
  cameraY = 15.5;
  cameraZ = 16;
  pitch = 0;
  return yaw = 0;
};

renderCubes = function() {
  var currentParticle, j, k, l, ref, ref1, ref2, x, y, z;
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    for (y = k = 0, ref1 = gridSizeY; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
      for (z = l = 0, ref2 = gridSizeZ; 0 <= ref2 ? l < ref2 : l > ref2; z = 0 <= ref2 ? ++l : --l) {
        currentParticle = particleAt[x][y][z];
        if (currentParticle) {
          if ((x === gridSizeX - 1 || !particleAt[x + 1][y][z]) && x < cameraX) {
            face(currentParticle, FACE_RIGHT, x + 1, y, z + 1);
          }
          if ((x === 0 || !particleAt[x - 1][y][z]) && x > cameraX) {
            face(currentParticle, FACE_LEFT, x, y, z + 1);
          }
          if ((y === gridSizeY - 1 || !particleAt[x][y + 1][z]) && y < cameraY) {
            face(currentParticle, FACE_BOTTOM, x, y + 1, z);
          }
          if ((y === 0 || !particleAt[x][y - 1][z]) && y > cameraY) {
            face(currentParticle, FACE_TOP, x, y, z);
          }
          if ((z === gridSizeZ - 1 || !particleAt[x][y][z + 1]) && z < cameraZ) {
            face(currentParticle, FACE_FRONT, x, y, z + 1);
          }
          if ((z === 0 || !particleAt[x][y][z - 1]) && z > cameraZ) {
            face(currentParticle, FACE_BACK, x, y, z);
          }
        }
      }
    }
  }
  return flushFaces();
};

particlesMotion = function() {
  var elementDensityXYZ, exitFor, horizChance, i, j, k, l, len, len1, len2, len3, n, o, p, particleNextTickAtXYZ, perm, q, rand1, rand2, ref, ref1, ref2, results, results1, results2, results3, results4, results5, s, t, tmp, u, vertChance, x, xOrder, y, yOrder, z, zOrder;
  if (Math.random() < 0.5) {
    xOrder = (function() {
      results = [];
      for (var j = 0; 0 <= gridSizeX ? j < gridSizeX : j > gridSizeX; 0 <= gridSizeX ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this);
  } else {
    xOrder = (function() {
      results1 = [];
      for (var k = ref = gridSizeX - 1; ref <= 0 ? k <= 0 : k >= 0; ref <= 0 ? k++ : k--){ results1.push(k); }
      return results1;
    }).apply(this);
  }
  if (Math.random() < 0.5) {
    yOrder = (function() {
      results2 = [];
      for (var l = 0; 0 <= gridSizeY ? l < gridSizeY : l > gridSizeY; 0 <= gridSizeY ? l++ : l--){ results2.push(l); }
      return results2;
    }).apply(this);
  } else {
    yOrder = (function() {
      results3 = [];
      for (var n = ref1 = gridSizeY - 1; ref1 <= 0 ? n <= 0 : n >= 0; ref1 <= 0 ? n++ : n--){ results3.push(n); }
      return results3;
    }).apply(this);
  }
  if (Math.random() < 0.5) {
    zOrder = (function() {
      results4 = [];
      for (var o = 0; 0 <= gridSizeZ ? o < gridSizeZ : o > gridSizeZ; 0 <= gridSizeZ ? o++ : o--){ results4.push(o); }
      return results4;
    }).apply(this);
  } else {
    zOrder = (function() {
      results5 = [];
      for (var p = ref2 = gridSizeZ - 1; ref2 <= 0 ? p <= 0 : p >= 0; ref2 <= 0 ? p++ : p--){ results5.push(p); }
      return results5;
    }).apply(this);
  }
  for (q = 0, len = xOrder.length; q < len; q++) {
    x = xOrder[q];
    for (s = 0, len1 = yOrder.length; s < len1; s++) {
      y = yOrder[s];
      for (t = 0, len2 = zOrder.length; t < len2; t++) {
        z = zOrder[t];
        particleNextTickAtXYZ = particleNextTickAt[x][y][z];
        if (particleNextTickAtXYZ > 0) {
          rand1 = Math.random();
          rand2 = Math.random();
          horizChance = horizontalMotionProbability[particleNextTickAtXYZ];
          vertChance = Math.abs(verticalMotionProbability[particleNextTickAtXYZ]);
          if (rand1 < horizChance && rand2 < vertChance) {
            perm = perm5[Math.floor(Math.random() * perm5.length)];
          } else if (rand1 < horizChance && rand2 > vertChance) {
            perm = perm4[Math.floor(Math.random() * perm4.length)];
          } else if (rand1 > horizChance && rand2 < vertChance) {
            perm = [4];
          } else if (rand1 > horizChance && rand2 > vertChance) {
            continue;
          }
          elementDensityXYZ = elementDensity[particleNextTickAtXYZ];
          exitFor = false;
          for (u = 0, len3 = perm.length; u < len3; u++) {
            i = perm[u];
            if (exitFor) {
              break;
            }
            switch (i) {
              case 0:
                if (x > 0 && elementDensityXYZ > elementDensity[particleNextTickAt[x - 1][y][z]]) {
                  tmp = particleNextTickAtXYZ;
                  particleNextTickAt[x][y][z] = particleNextTickAt[x - 1][y][z];
                  particleNextTickAt[x - 1][y][z] = tmp;
                  exitFor = true;
                }
                break;
              case 1:
                if (x < gridSizeX - 1 && elementDensityXYZ > elementDensity[particleNextTickAt[x + 1][y][z]]) {
                  tmp = particleNextTickAtXYZ;
                  particleNextTickAt[x][y][z] = particleNextTickAt[x + 1][y][z];
                  particleNextTickAt[x + 1][y][z] = tmp;
                  exitFor = true;
                }
                break;
              case 2:
                if (y > 0 && elementDensityXYZ > elementDensity[particleNextTickAt[x][y - 1][z]]) {
                  tmp = particleNextTickAtXYZ;
                  particleNextTickAt[x][y][z] = particleNextTickAt[x][y - 1][z];
                  particleNextTickAt[x][y - 1][z] = tmp;
                  exitFor = true;
                }
                break;
              case 3:
                if (y < gridSizeY - 1 && elementDensityXYZ > elementDensity[particleNextTickAt[x][y + 1][z]]) {
                  tmp = particleNextTickAtXYZ;
                  particleNextTickAt[x][y][z] = particleNextTickAt[x][y + 1][z];
                  particleNextTickAt[x][y + 1][z] = tmp;
                  exitFor = true;
                }
                break;
              case 4:
                if (verticalMotionProbability[particleNextTickAtXYZ] > 0) {
                  if (z > 0 && elementDensity[particleNextTickAtXYZ] > elementDensity[particleNextTickAt[x][y][z - 1]]) {
                    tmp = particleNextTickAtXYZ;
                    particleNextTickAt[x][y][z] = particleNextTickAt[x][y][z - 1];
                    particleNextTickAt[x][y][z - 1] = tmp;
                    exitFor = true;
                  }
                } else if (verticalMotionProbability[particleNextTickAtXYZ] < 0) {
                  if (z < gridSizeZ - 1 && elementDensity[particleNextTickAtXYZ] > elementDensity[particleNextTickAt[x][y][z + 1]]) {
                    tmp = particleNextTickAtXYZ;
                    particleNextTickAt[x][y][z] = particleNextTickAt[x][y][z + 1];
                    particleNextTickAt[x][y][z + 1] = tmp;
                    exitFor = true;
                  }
                }
            }
          }
        }
      }
    }
  }
};

shuffledProbs = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];

shuffledDirections = [0, 0, 0, 0, 0, 0];

particlesReactions = function() {
  var checkVal, currentParticle, howManyPossibleReactions, i, j, k, l, n, reactionOptionsOfCurrentParticleWith, reactionProbabilityOfCurrentParticleWith, ref, ref1, ref2, shuffle, sixDirections, sixProbs, tmp, x, y, z;
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    for (y = k = 0, ref1 = gridSizeY; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
      for (z = l = 0, ref2 = gridSizeZ; 0 <= ref2 ? l < ref2 : l > ref2; z = 0 <= ref2 ? ++l : --l) {
        currentParticle = particleAt[x][y][z];
        if (currentParticle === 0) {
          if (x === 0 || particleAt[x - 1][y][z] === 0) {
            if (y === 0 || particleAt[x][y - 1][z] === 0) {
              if (z === 0 || particleAt[x][y][z - 1] === 0) {
                if (x === gridSizeX - 1 || particleAt[x + 1][y][z] === 0) {
                  if (y === gridSizeY - 1 || particleAt[x][y + 1][z] === 0) {
                    if (z === gridSizeZ - 1 || particleAt[x][y][z + 1] === 0) {
                      particleNextTickAt[x][y][z] = currentParticle;
                      continue;
                    }
                  }
                }
              }
            }
          }
        }
        if (Math.random() <= transmutationProbability[currentParticle]) {
          particleAt[x][y][z] = transmutationTo[currentParticle];
          particleNextTickAt[x][y][z] = particleAt[x][y][z];
          continue;
        }
        particleNextTickAt[x][y][z] = currentParticle;
        sixProbs = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
        sixDirections = [0, 1, 2, 3, 4, 5];
        reactionOptionsOfCurrentParticleWith = reactionOptions[currentParticle];
        reactionProbabilityOfCurrentParticleWith = neighborProbability[currentParticle];
        howManyPossibleReactions = 0;
        if (x > 0) {
          checkVal = reactionOptionsOfCurrentParticleWith[particleAt[x - 1][y][z]];
          if (checkVal !== -1) {
            sixProbs[0] = reactionProbabilityOfCurrentParticleWith[particleAt[x - 1][y][z]];
            howManyPossibleReactions++;
          }
        }
        if (y > 0) {
          checkVal = reactionOptionsOfCurrentParticleWith[particleAt[x][y - 1][z]];
          if (checkVal !== -1) {
            sixProbs[1] = reactionProbabilityOfCurrentParticleWith[particleAt[x][y - 1][z]];
            howManyPossibleReactions++;
          }
        }
        if (z > 0) {
          checkVal = reactionOptionsOfCurrentParticleWith[particleAt[x][y][z - 1]];
          if (checkVal !== -1) {
            sixProbs[2] = reactionProbabilityOfCurrentParticleWith[particleAt[x][y][z - 1]];
            howManyPossibleReactions++;
          }
        }
        if (x < gridSizeX - 1) {
          checkVal = reactionOptionsOfCurrentParticleWith[particleAt[x + 1][y][z]];
          if (checkVal !== -1) {
            sixProbs[3] = reactionProbabilityOfCurrentParticleWith[particleAt[x + 1][y][z]];
            howManyPossibleReactions++;
          }
        }
        if (y < gridSizeY - 1) {
          checkVal = reactionOptionsOfCurrentParticleWith[particleAt[x][y + 1][z]];
          if (checkVal !== -1) {
            sixProbs[4] = reactionProbabilityOfCurrentParticleWith[particleAt[x][y + 1][z]];
            howManyPossibleReactions++;
          }
        }
        if (z < gridSizeZ - 1) {
          checkVal = reactionOptionsOfCurrentParticleWith[particleAt[x][y][z + 1]];
          if (checkVal !== -1) {
            sixProbs[5] = reactionProbabilityOfCurrentParticleWith[particleAt[x][y][z + 1]];
            howManyPossibleReactions++;
          }
        }
        if (howManyPossibleReactions === 0) {
          particleNextTickAt[x][y][z] = particleAt[x][y][z];
          continue;
        }
        shuffle = perm6[Math.floor(Math.random() * perm6.length)];
        shuffledProbs[0] = sixProbs[shuffle[0]];
        shuffledProbs[1] = sixProbs[shuffle[1]];
        shuffledProbs[2] = sixProbs[shuffle[2]];
        shuffledProbs[3] = sixProbs[shuffle[3]];
        shuffledProbs[4] = sixProbs[shuffle[4]];
        shuffledProbs[5] = sixProbs[shuffle[5]];
        shuffledDirections[0] = sixDirections[shuffle[0]];
        shuffledDirections[1] = sixDirections[shuffle[1]];
        shuffledDirections[2] = sixDirections[shuffle[2]];
        shuffledDirections[3] = sixDirections[shuffle[3]];
        shuffledDirections[4] = sixDirections[shuffle[4]];
        shuffledDirections[5] = sixDirections[shuffle[5]];
        if (shuffledProbs[2] > shuffledProbs[1]) {
          tmp = shuffledProbs[1];
          shuffledProbs[1] = shuffledProbs[2];
          shuffledProbs[2] = tmp;
          tmp = shuffledDirections[1];
          shuffledDirections[1] = shuffledDirections[2];
          shuffledDirections[2] = tmp;
        }
        if (shuffledProbs[2] > shuffledProbs[0]) {
          tmp = shuffledProbs[0];
          shuffledProbs[0] = shuffledProbs[2];
          shuffledProbs[2] = tmp;
          tmp = shuffledDirections[0];
          shuffledDirections[0] = shuffledDirections[2];
          shuffledDirections[2] = tmp;
        }
        if (shuffledProbs[1] > shuffledProbs[0]) {
          tmp = shuffledProbs[0];
          shuffledProbs[0] = shuffledProbs[1];
          shuffledProbs[1] = tmp;
          tmp = shuffledDirections[0];
          shuffledDirections[0] = shuffledDirections[1];
          shuffledDirections[1] = tmp;
        }
        if (shuffledProbs[5] > shuffledProbs[4]) {
          tmp = shuffledProbs[4];
          shuffledProbs[4] = shuffledProbs[5];
          shuffledProbs[5] = tmp;
          tmp = shuffledDirections[4];
          shuffledDirections[4] = shuffledDirections[5];
          shuffledDirections[5] = tmp;
        }
        if (shuffledProbs[5] > shuffledProbs[3]) {
          tmp = shuffledProbs[3];
          shuffledProbs[3] = shuffledProbs[5];
          shuffledProbs[5] = tmp;
          tmp = shuffledDirections[3];
          shuffledDirections[3] = shuffledDirections[5];
          shuffledDirections[5] = tmp;
        }
        if (shuffledProbs[4] > shuffledProbs[3]) {
          tmp = shuffledProbs[3];
          shuffledProbs[3] = shuffledProbs[4];
          shuffledProbs[4] = tmp;
          tmp = shuffledDirections[3];
          shuffledDirections[3] = shuffledDirections[4];
          shuffledDirections[4] = tmp;
        }
        if (shuffledProbs[3] > shuffledProbs[0]) {
          tmp = shuffledProbs[0];
          shuffledProbs[0] = shuffledProbs[3];
          shuffledProbs[3] = tmp;
          tmp = shuffledDirections[0];
          shuffledDirections[0] = shuffledDirections[3];
          shuffledDirections[3] = tmp;
        }
        if (shuffledProbs[4] > shuffledProbs[1]) {
          tmp = shuffledProbs[1];
          shuffledProbs[1] = shuffledProbs[4];
          shuffledProbs[4] = tmp;
          tmp = shuffledDirections[1];
          shuffledDirections[1] = shuffledDirections[4];
          shuffledDirections[4] = tmp;
        }
        if (shuffledProbs[5] > shuffledProbs[2]) {
          tmp = shuffledProbs[2];
          shuffledProbs[2] = shuffledProbs[5];
          shuffledProbs[5] = tmp;
          tmp = shuffledDirections[2];
          shuffledDirections[2] = shuffledDirections[5];
          shuffledDirections[5] = tmp;
        }
        if (shuffledProbs[4] > shuffledProbs[2]) {
          tmp = shuffledProbs[2];
          shuffledProbs[2] = shuffledProbs[4];
          shuffledProbs[4] = tmp;
          tmp = shuffledDirections[2];
          shuffledDirections[2] = shuffledDirections[4];
          shuffledDirections[4] = tmp;
        }
        if (shuffledProbs[3] > shuffledProbs[1]) {
          tmp = shuffledProbs[1];
          shuffledProbs[1] = shuffledProbs[3];
          shuffledProbs[3] = tmp;
          tmp = shuffledDirections[1];
          shuffledDirections[1] = shuffledDirections[3];
          shuffledDirections[3] = tmp;
        }
        if (shuffledProbs[3] > shuffledProbs[2]) {
          tmp = shuffledProbs[2];
          shuffledProbs[2] = shuffledProbs[3];
          shuffledProbs[3] = tmp;
          tmp = shuffledDirections[2];
          shuffledDirections[2] = shuffledDirections[3];
          shuffledDirections[3] = tmp;
        }
        sixProbs = shuffledProbs;
        sixDirections = shuffledDirections;
        for (i = n = 0; n < 6; i = ++n) {
          if (sixProbs[i] === 0) {
            break;
          }
          if (Math.random() < sixProbs[i]) {
            switch (sixDirections[i]) {
              case 0:
                particleNextTickAt[x][y][z] = reactionOptions[currentParticle][particleAt[x - 1][y][z]];
                break;
              case 1:
                particleNextTickAt[x][y][z] = reactionOptions[currentParticle][particleAt[x][y - 1][z]];
                break;
              case 2:
                particleNextTickAt[x][y][z] = reactionOptions[currentParticle][particleAt[x][y][z - 1]];
                break;
              case 3:
                particleNextTickAt[x][y][z] = reactionOptions[currentParticle][particleAt[x + 1][y][z]];
                break;
              case 4:
                particleNextTickAt[x][y][z] = reactionOptions[currentParticle][particleAt[x][y + 1][z]];
                break;
              case 5:
                particleNextTickAt[x][y][z] = reactionOptions[currentParticle][particleAt[x][y][z + 1]];
            }
            break;
          }
        }
      }
    }
  }
};

numberOfParticles = 0;

instrumentation_countParticles = function() {
  var j, k, l, ref, ref1, ref2, x, y, z;
  numberOfParticles = 0;
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    for (y = k = 0, ref1 = gridSizeY; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
      for (z = l = 0, ref2 = gridSizeZ; 0 <= ref2 ? l < ref2 : l > ref2; z = 0 <= ref2 ? ++l : --l) {
        if (particleAt[x][y][z] !== 0) {
          numberOfParticles++;
        }
      }
    }
  }
};

rayCast = function() {
  var i, j, marchingPointX, marchingPointY, marchingPointZ, rayMarching, ref;
  for (i = j = 0; j < 200; i = ++j) {
    rayMarching = i * 0.1;
    ref = fromCameraCalculateMoveOf(rayMarching, 0, 0), marchingPointX = ref[0], marchingPointY = ref[1], marchingPointZ = ref[2];
    marchingPointX = Math.round(marchingPointX);
    marchingPointY = Math.round(marchingPointY);
    marchingPointZ = Math.round(marchingPointZ);
    if (marchingPointX >= 0 && marchingPointX < gridSizeX && marchingPointY >= 0 && marchingPointY < gridSizeY && marchingPointZ >= 0 && marchingPointZ < gridSizeZ) {
      if (particleAt[marchingPointX][marchingPointY][marchingPointZ] !== 0) {
        rayCastSlot = [marchingPointX, marchingPointY, marchingPointZ];
        break;
      } else {
        justInFrontOfRayCastSlot = [marchingPointX, marchingPointY, marchingPointZ];
      }
    }
  }
};

ticks = 0;

fps_frameCount = 0;

tick = function() {
  var cameraMoveAmount, cameraMoveForward, cameraMoveSide, cameraMoveUp, cameraPitchDelta, cameraYawDelta, debugText, modelViewOrig, newScale, percentageBigger, ref, skipBecauseSlowDown;
  ticks++;
  fps_frameCount++;
  curContext.clear(curContext.DEPTH_BUFFER_BIT);
  curContextCache = {
    attributes: {},
    locations: {}
  };
  camera();
  cameraMoveForward = 0.0;
  cameraMoveSide = 0.0;
  cameraMoveUp = 0.0;
  cameraMoveAmount = 0.5;
  cameraYawDelta = 0.0;
  cameraPitchDelta = 0.0;
  if (isKeyPressed["w"]) {
    cameraMoveForward += cameraMoveAmount;
  }
  if (isKeyPressed["a"]) {
    cameraMoveSide += cameraMoveAmount;
  }
  if (isKeyPressed["s"]) {
    cameraMoveForward -= cameraMoveAmount;
  }
  if (isKeyPressed["d"]) {
    cameraMoveSide -= cameraMoveAmount;
  }
  if (isKeyPressed["Shift"]) {
    cameraMoveUp -= cameraMoveAmount;
    pitch += cameraMoveAmount / 50;
  }
  if (isKeyPressed[" "]) {
    cameraMoveUp += cameraMoveAmount;
    pitch -= cameraMoveAmount / 50;
  }
  if (isKeyPressed["ArrowLeft"]) {
    cameraYawDelta -= 0.05;
  }
  if (isKeyPressed["ArrowRight"]) {
    cameraYawDelta += 0.05;
  }
  if (isKeyPressed["ArrowUp"]) {
    cameraPitchDelta -= 0.05;
  }
  if (isKeyPressed["ArrowDown"]) {
    cameraPitchDelta += 0.05;
  }
  yaw += smoothed_YAW(cameraYawDelta);
  pitch += smoothed_PITCH(cameraPitchDelta);
  updateCamera(smoothed_FWD(cameraMoveForward), smoothed_SIDE(cameraMoveSide), smoothed_UP(cameraMoveUp));
  rayCastSlot[0] = -1;
  justInFrontOfRayCastSlot[0] = -1;
  rayCast();
  if ((slowDown === 1) && ticks % 20 !== 0) {
    skipBecauseSlowDown = true;
  } else {
    skipBecauseSlowDown = false;
  }
  if (!pauseReactionsAndMotion && !skipBecauseSlowDown) {
    particlesReactions_t0 = performance.now();
    particlesReactions();
    particlesReactions_tf = performance.now();
    particlesMotion_t0 = performance.now();
    particlesMotion();
    particlesMotion_tf = performance.now();
    instrumentation_countParticles_t0 = performance.now();
    instrumentation_countParticles();
    instrumentation_countParticles_tf = performance.now();
    ref = [particleNextTickAt, particleAt], particleAt = ref[0], particleNextTickAt = ref[1];
  }
  if (!pauseRendering) {
    camera(cameraX, cameraY, cameraZ, cameraDirectionX, cameraDirectionY, cameraDirectionZ, 0, 0, 1);
    background(backgroundColor);
    render_t0 = performance.now();
    renderCubes();
    render_tf = performance.now();
    if (rayCastSlot[0] !== -1) {
      stroke(0, 255, 255);
      modelViewOrig = modelView.get();
      newScale = 1 + 0.1;
      modelView.translate(rayCastSlot);
      modelView.translate(0.5, 0.5, 0.5);
      modelView.scale(newScale);
      modelView.translate(-rayCastSlot[0] - 0.5, -rayCastSlot[1] - 0.5, -rayCastSlot[2] - 0.5);
      boxStroke(rayCastSlot[0], rayCastSlot[1], rayCastSlot[2], 1, 1, 1);
      modelView.set(modelViewOrig);
    }
    if (justInFrontOfRayCastSlot[0] !== -1) {
      stroke(0, 255, 255);
      modelViewOrig = modelView.get();
      newScale = 0.9;
      modelView.translate(justInFrontOfRayCastSlot);
      modelView.translate(0.5, 0.5, 0.5);
      modelView.scale(newScale);
      modelView.translate(-justInFrontOfRayCastSlot[0] - 0.5, -justInFrontOfRayCastSlot[1] - 0.5, -justInFrontOfRayCastSlot[2] - 0.5);
      boxDottedStroke(5, justInFrontOfRayCastSlot[0], justInFrontOfRayCastSlot[1], justInFrontOfRayCastSlot[2], 1, 1, 1);
      modelView.set(modelViewOrig);
    }
    stroke(0, 255, 255);
    percentageBigger = 5 / 100;
    modelView.translate(-gridSizeX * percentageBigger / 2, -gridSizeY * percentageBigger / 2, -gridSizeZ * percentageBigger / 2);
    modelView.scale(1 + percentageBigger);
    containerBox(0, 0, 0, gridSizeX, gridSizeY, gridSizeZ);
  }
  if (ticks % 30 === 0) {
    debugText = 'FPS: ' + Math.round(fps_frameCount / ((performance.now() - last_fps_count_time) / 1000)) + '\nPlace: ' + elementName[elementChosenByUserToBeAddedToWorld];
    last_fps_count_time = performance.now();
    fps_frameCount = 0;
    if (DEBUG_UI) {
      debugText += ' rendering ms: ' + (render_tf - render_t0).toFixed(2);
      debugText += ' reactions ms: ' + (particlesReactions_tf - particlesReactions_t0 + particlesMotion_tf - particlesMotion_t0 + instrumentation_countParticles_tf - instrumentation_countParticles_t0).toFixed(2);
      debugText += ' particlesReactions ms: ' + (particlesReactions_tf - particlesReactions_t0).toFixed(2);
      debugText += ' particlesMotion ms: ' + (particlesMotion_tf - particlesMotion_t0).toFixed(2);
      debugText += ' instrumentation_countParticles ms: ' + (instrumentation_countParticles_tf - instrumentation_countParticles_t0).toFixed(2);
      if (pauseReactionsAndMotion) {
        debugText = debugText + ' REACTIONS AND MOTION PAUSED';
      }
      if (pauseRendering) {
        debugText = debugText + ' RENDERING PAUSED';
      }
      debugText += ' camera x: ' + cameraX.toFixed(2);
      debugText += ' camera y: ' + cameraY.toFixed(2);
      debugText += ' camera z: ' + cameraZ.toFixed(2);
      debugText += ' pitch: ' + pitch.toFixed(2);
      debugText += ' yaw: ' + yaw.toFixed(2);
      debugText += ' numberOfParticles: ' + numberOfParticles;
      document.getElementById('status-info').innerHTML = debugText;
    }
  }
  return requestAnimationFrame(tick);
};

requestAnimationFrame(tick);

canvasElement.addEventListener('contextmenu', function(e) {
  e.preventDefault();
  return e.stopPropagation();
});

previousMouseX = 0;

previousMouseY = 0;

mouseX = 0;

mouseY = 0;

canvasElement.addEventListener('mousemove', function(e) {
  previousMouseX = mouseX;
  previousMouseY = mouseY;
  mouseX = e.offsetX;
  mouseY = e.offsetY;
  if (e.buttons === 1) {
    mouseDraggedLeftButton();
  }
});

placeElement = function() {
  if (justInFrontOfRayCastSlot[0] !== -1 && elementChosenByUserToBeAddedToWorld !== 0) {
    return particleAt[justInFrontOfRayCastSlot[0]][justInFrontOfRayCastSlot[1]][justInFrontOfRayCastSlot[2]] = elementChosenByUserToBeAddedToWorld;
  }
};

canvasElement.addEventListener('mousedown', function(e) {
  if (e.buttons === 2) {
    return placeElement();
  }
});

mouseDraggedLeftButton = function() {
  var deltaX, deltaY;
  deltaX = (previousMouseX - mouseX) * invertHorizMouseDrag;
  deltaY = (previousMouseY - mouseY) * invertHorizMouseDrag * -1;
  yaw = yaw + deltaX * mouseSensitivity;
  return pitch = pitch + deltaY * mouseSensitivity;
};

isKeyPressed = {};

handleKeydown = function(e) {
  isKeyPressed[e.key] = true;
  return true;
};

handleKeyup = function(e) {
  if (isKeyPressed[e.key]) {
    delete isKeyPressed[e.key];
  }
  if (e.key === 'Backspace' || e.key === 'Delete') {
    if (rayCastSlot[0] !== -1) {
      particleAt[rayCastSlot[0]][rayCastSlot[1]][rayCastSlot[2]] = 0;
    }
  }
  if (e.key === 'Escape' && currentlyOpenModal) {
    dismissModal(currentlyOpenModal);
  }
  return true;
};

keyPressed = function(e) {
  var key;
  key = e.key;
  if (key === 'o') {
    pitch = 0;
    yaw = 0;
    cameraX = 0;
    cameraY = 0;
    cameraZ = 0;
  }
  if (key === 'p') {
    pauseReactionsAndMotion = !pauseReactionsAndMotion;
  }
  if (key === '1') {
    bringUpElementList("gas");
  }
  if (key === '2') {
    bringUpElementList("liquid");
  }
  if (key === '3') {
    bringUpElementList("solid");
  }
  if (key === '4') {
    bringUpElementList("flammable");
  }
  if (key === 'e') {
    if (currentlyOpenModal === examplesModal) {
      examplesSelectList.selectedIndex = (examplesSelectList.selectedIndex + examplesSelectList.length - 1) % examplesSelectList.length;
    } else {
      elementSelectList.selectedIndex = (elementSelectList.selectedIndex + elementSelectList.length - 1) % elementSelectList.length;
      updateChosenItemBasedOnSelect();
    }
  }
  if (key === 'r') {
    if (currentlyOpenModal === examplesModal) {
      examplesSelectList.selectedIndex = (examplesSelectList.selectedIndex + 1) % examplesSelectList.length;
    } else {
      elementSelectList.selectedIndex = (elementSelectList.selectedIndex + 1) % elementSelectList.length;
      updateChosenItemBasedOnSelect();
    }
  }
  if (key === 'Enter') {
    if (currentlyOpenModal) {
      if (currentlyOpenModal === examplesModal) {
        startSelectedExampleAndDismissExamplesModal();
      } else {
        dismissModal(currentlyOpenModal);
      }
    } else {
      placeElement();
    }
  }
  return e.preventDefault();
};

window.addEventListener('keydown', handleKeydown);

window.addEventListener('keypress', keyPressed);

window.addEventListener('keyup', handleKeyup);

clearAllSlots = function() {
  var j, ref, results, x, y, z;
  results = [];
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    results.push((function() {
      var k, ref1, results1;
      results1 = [];
      for (y = k = 0, ref1 = gridSizeY; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        results1.push((function() {
          var l, ref2, results2;
          results2 = [];
          for (z = l = 0, ref2 = gridSizeZ; 0 <= ref2 ? l < ref2 : l > ref2; z = 0 <= ref2 ? ++l : --l) {
            results2.push(particleAt[x][y][z] = elementName.indexOf("Void"));
          }
          return results2;
        })());
      }
      return results1;
    })());
  }
  return results;
};

scenario1 = function() {
  particleAt[2][0][0] = elementName.indexOf("Wall");
  particleAt[0][4][0] = elementName.indexOf("Wall");
  return particleAt[0][0][8] = elementName.indexOf("Wall");
};

scenario2 = function() {
  var j, ref, results, x, y;
  results = [];
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    results.push((function() {
      var k, ref1, results1;
      results1 = [];
      for (y = k = 0, ref1 = gridSizeY; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        results1.push(particleAt[x][y][0] = elementName.indexOf("Fire"));
      }
      return results1;
    })());
  }
  return results;
};

scenario3 = function() {
  return particleAt[Math.round(gridSizeX / 2)][Math.round(gridSizeY / 2)][Math.round(gridSizeZ / 2)] = elementName.indexOf("WaterFountain");
};

scenario4 = function() {
  return particleAt[Math.round(gridSizeX / 2)][Math.round(gridSizeY / 2)][Math.round(gridSizeZ / 2)] = elementName.indexOf("OilFountain");
};

scenario5 = function() {
  var j, ref, results, x, y;
  results = [];
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    results.push((function() {
      var k, ref1, results1;
      results1 = [];
      for (y = k = 0, ref1 = gridSizeY; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        results1.push(particleAt[x][y][0] = elementName.indexOf("Steam"));
      }
      return results1;
    })());
  }
  return results;
};

scenario6 = function() {
  particleAt[0][0][Math.round(gridSizeZ / 2)] = elementName.indexOf("WaterFountain");
  return particleAt[gridSizeX - 1][gridSizeX - 1][Math.round(gridSizeZ / 2)] = elementName.indexOf("OilFountain");
};

scenario7 = function() {
  particleAt[0][0][Math.round(gridSizeZ / 2)] = elementName.indexOf("WaterFountain");
  particleAt[gridSizeX - 1][gridSizeX - 1][Math.round(gridSizeZ / 2)] = elementName.indexOf("OilFountain");
  return particleAt[Math.round(gridSizeX / 2)][Math.round(gridSizeY / 2)][5] = elementName.indexOf("Torch");
};

scenario8 = function() {
  var j, k, l, n, ref, ref1, ref2, ref3, results, x, y, z;
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    for (y = k = 0, ref1 = gridSizeY; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
      for (z = l = 0, ref2 = Math.round(gridSizeZ / 2); 0 <= ref2 ? l < ref2 : l > ref2; z = 0 <= ref2 ? ++l : --l) {
        particleAt[x][y][z] = elementName.indexOf("Oil");
      }
    }
  }
  results = [];
  for (x = n = 0, ref3 = gridSizeX; 0 <= ref3 ? n < ref3 : n > ref3; x = 0 <= ref3 ? ++n : --n) {
    results.push((function() {
      var o, ref4, results1;
      results1 = [];
      for (y = o = 0, ref4 = gridSizeY; 0 <= ref4 ? o < ref4 : o > ref4; y = 0 <= ref4 ? ++o : --o) {
        results1.push((function() {
          var p, ref5, ref6, results2;
          results2 = [];
          for (z = p = ref5 = Math.round(gridSizeZ / 2), ref6 = gridSizeZ; ref5 <= ref6 ? p < ref6 : p > ref6; z = ref5 <= ref6 ? ++p : --p) {
            results2.push(particleAt[x][y][z] = elementName.indexOf("Water"));
          }
          return results2;
        })());
      }
      return results1;
    })());
  }
  return results;
};

scenario9 = function() {
  var j, k, l, n, ref, ref1, ref2, ref3, results, x, y, z;
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    for (y = k = 0, ref1 = Math.round(gridSizeY / 2); 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
      for (z = l = 0, ref2 = gridSizeZ; 0 <= ref2 ? l < ref2 : l > ref2; z = 0 <= ref2 ? ++l : --l) {
        particleAt[x][y][z] = elementName.indexOf("Oil");
      }
    }
  }
  results = [];
  for (x = n = 0, ref3 = gridSizeX; 0 <= ref3 ? n < ref3 : n > ref3; x = 0 <= ref3 ? ++n : --n) {
    results.push((function() {
      var o, ref4, ref5, results1;
      results1 = [];
      for (y = o = ref4 = Math.round(gridSizeY / 2), ref5 = gridSizeY; ref4 <= ref5 ? o < ref5 : o > ref5; y = ref4 <= ref5 ? ++o : --o) {
        results1.push((function() {
          var p, ref6, results2;
          results2 = [];
          for (z = p = 0, ref6 = gridSizeZ; 0 <= ref6 ? p < ref6 : p > ref6; z = 0 <= ref6 ? ++p : --p) {
            results2.push(particleAt[x][y][z] = elementName.indexOf("Water"));
          }
          return results2;
        })());
      }
      return results1;
    })());
  }
  return results;
};

scenario10 = function() {
  var j, ref, results, x, y, z;
  results = [];
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    results.push((function() {
      var k, ref1, ref2, results1;
      results1 = [];
      for (y = k = ref1 = Math.round(gridSizeY / 3), ref2 = Math.round(2 * gridSizeY / 3); ref1 <= ref2 ? k < ref2 : k > ref2; y = ref1 <= ref2 ? ++k : --k) {
        results1.push((function() {
          var l, ref3, results2;
          results2 = [];
          for (z = l = 0, ref3 = gridSizeZ; 0 <= ref3 ? l < ref3 : l > ref3; z = 0 <= ref3 ? ++l : --l) {
            results2.push(particleAt[x][y][z] = elementName.indexOf("Water"));
          }
          return results2;
        })());
      }
      return results1;
    })());
  }
  return results;
};

scenario11 = function() {
  var j, ref, results, x, y, z;
  results = [];
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    results.push((function() {
      var k, ref1, results1;
      results1 = [];
      for (y = k = 0, ref1 = gridSizeY; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        results1.push((function() {
          var l, ref2, results2;
          results2 = [];
          for (z = l = 0, ref2 = gridSizeZ; 0 <= ref2 ? l < ref2 : l > ref2; z = 0 <= ref2 ? ++l : --l) {
            results2.push(particleAt[x][y][z] = Math.floor(Math.random() * 10));
          }
          return results2;
        })());
      }
      return results1;
    })());
  }
  return results;
};

scenario12 = function() {
  var j, k, l, n, o, ref, ref1, ref2, ref3, ref4, ref5, results, x, y;
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    for (y = k = 0, ref1 = Math.round(gridSizeY / 2); 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
      particleAt[x][y][Math.round(gridSizeY / 3)] = elementName.indexOf("Wall");
    }
  }
  for (x = l = 0, ref2 = gridSizeX; 0 <= ref2 ? l < ref2 : l > ref2; x = 0 <= ref2 ? ++l : --l) {
    for (y = n = ref3 = Math.round(gridSizeY / 2), ref4 = gridSizeY; ref3 <= ref4 ? n < ref4 : n > ref4; y = ref3 <= ref4 ? ++n : --n) {
      particleAt[x][y][Math.round(2 * gridSizeY / 3)] = elementName.indexOf("Wall");
    }
  }
  results = [];
  for (x = o = 0, ref5 = gridSizeX; 0 <= ref5 ? o < ref5 : o > ref5; x = 0 <= ref5 ? ++o : --o) {
    results.push((function() {
      var p, ref6, results1;
      results1 = [];
      for (y = p = 0, ref6 = gridSizeY; 0 <= ref6 ? p < ref6 : p > ref6; y = 0 <= ref6 ? ++p : --p) {
        results1.push(particleAt[x][y][0] = elementName.indexOf("Steam"));
      }
      return results1;
    })());
  }
  return results;
};

scenario13 = function() {
  var j, k, l, ref, ref1, ref2, results, x, y;
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    for (y = k = 0, ref1 = gridSizeY; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
      particleAt[x][y][0] = elementName.indexOf("Steam");
    }
  }
  results = [];
  for (y = l = 0, ref2 = gridSizeY; 0 <= ref2 ? l < ref2 : l > ref2; y = 0 <= ref2 ? ++l : --l) {
    results.push((function() {
      var n, ref3, results1;
      results1 = [];
      for (x = n = 0, ref3 = gridSizeX; 0 <= ref3 ? n < ref3 : n > ref3; x = 0 <= ref3 ? ++n : --n) {
        results1.push(particleAt[x][y][y] = elementName.indexOf("Wall"));
      }
      return results1;
    })());
  }
  return results;
};

scenario14 = function() {
  var j, k, l, n, ref, ref1, ref2, ref3, results, x, y, z;
  for (y = j = 0, ref = Math.round(gridSizeY / 2); 0 <= ref ? j < ref : j > ref; y = 0 <= ref ? ++j : --j) {
    for (x = k = 0, ref1 = gridSizeX; 0 <= ref1 ? k < ref1 : k > ref1; x = 0 <= ref1 ? ++k : --k) {
      for (z = l = 0, ref2 = y; 0 <= ref2 ? l < ref2 : l > ref2; z = 0 <= ref2 ? ++l : --l) {
        particleAt[x][y][z] = elementName.indexOf("Steam");
      }
    }
  }
  results = [];
  for (y = n = 0, ref3 = gridSizeY; 0 <= ref3 ? n < ref3 : n > ref3; y = 0 <= ref3 ? ++n : --n) {
    results.push((function() {
      var o, ref4, results1;
      results1 = [];
      for (x = o = 0, ref4 = gridSizeX; 0 <= ref4 ? o < ref4 : o > ref4; x = 0 <= ref4 ? ++o : --o) {
        results1.push(particleAt[x][y][y] = elementName.indexOf("Wall"));
      }
      return results1;
    })());
  }
  return results;
};

scenario15 = function() {
  var j, k, l, ref, ref1, ref2, results, x, y;
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    for (y = k = 0, ref1 = gridSizeY; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
      particleAt[x][y][gridSizeZ - 1] = elementName.indexOf("Water");
    }
  }
  results = [];
  for (y = l = 0, ref2 = gridSizeY; 0 <= ref2 ? l < ref2 : l > ref2; y = 0 <= ref2 ? ++l : --l) {
    results.push((function() {
      var n, ref3, results1;
      results1 = [];
      for (x = n = 0, ref3 = gridSizeX; 0 <= ref3 ? n < ref3 : n > ref3; x = 0 <= ref3 ? ++n : --n) {
        results1.push(particleAt[x][y][y] = elementName.indexOf("Wall"));
      }
      return results1;
    })());
  }
  return results;
};

scenario16 = function() {
  var j, k, l, n, ref, ref1, ref2, ref3, ref4, ref5, results, x, y, z;
  for (y = j = ref = Math.round(gridSizeY / 2), ref1 = gridSizeY; ref <= ref1 ? j < ref1 : j > ref1; y = ref <= ref1 ? ++j : --j) {
    for (x = k = 0, ref2 = gridSizeX; 0 <= ref2 ? k < ref2 : k > ref2; x = 0 <= ref2 ? ++k : --k) {
      for (z = l = ref3 = y, ref4 = gridSizeZ; ref3 <= ref4 ? l < ref4 : l > ref4; z = ref3 <= ref4 ? ++l : --l) {
        particleAt[x][y][z] = elementName.indexOf("Water");
      }
    }
  }
  results = [];
  for (y = n = 0, ref5 = gridSizeY; 0 <= ref5 ? n < ref5 : n > ref5; y = 0 <= ref5 ? ++n : --n) {
    results.push((function() {
      var o, ref6, results1;
      results1 = [];
      for (x = o = 0, ref6 = gridSizeX; 0 <= ref6 ? o < ref6 : o > ref6; x = 0 <= ref6 ? ++o : --o) {
        results1.push(particleAt[x][y][y] = elementName.indexOf("Wall"));
      }
      return results1;
    })());
  }
  return results;
};

scenario17 = function() {
  var j, k, l, n, o, ref, ref1, ref2, ref3, ref4, ref5, results, x, y;
  for (x = j = 0, ref = gridSizeX; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
    for (y = k = 0, ref1 = gridSizeY; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
      particleAt[x][y][gridSizeZ - 1] = elementName.indexOf("Water");
    }
  }
  for (y = l = 0, ref2 = Math.round(gridSizeY / 2) - 1; 0 <= ref2 ? l < ref2 : l > ref2; y = 0 <= ref2 ? ++l : --l) {
    for (x = n = 0, ref3 = gridSizeX; 0 <= ref3 ? n < ref3 : n > ref3; x = 0 <= ref3 ? ++n : --n) {
      particleAt[x][y][gridSizeY - y - 1] = elementName.indexOf("Wall");
    }
  }
  results = [];
  for (y = o = ref4 = Math.round(gridSizeY / 2) + 1, ref5 = gridSizeY; ref4 <= ref5 ? o < ref5 : o > ref5; y = ref4 <= ref5 ? ++o : --o) {
    results.push((function() {
      var p, ref6, results1;
      results1 = [];
      for (x = p = 0, ref6 = gridSizeX; 0 <= ref6 ? p < ref6 : p > ref6; x = 0 <= ref6 ? ++p : --p) {
        results1.push(particleAt[x][y][y] = elementName.indexOf("Wall"));
      }
      return results1;
    })());
  }
  return results;
};

scenario18 = function() {
  var gridSpacing, j, k, l, ref, ref1, ref2, x, y, z;
  gridSpacing = 4;
  for (x = j = 1, ref = gridSizeX; 1 <= ref ? j < ref : j > ref; x = 1 <= ref ? ++j : --j) {
    for (y = k = 1, ref1 = gridSizeY; 1 <= ref1 ? k < ref1 : k > ref1; y = 1 <= ref1 ? ++k : --k) {
      for (z = l = 1, ref2 = gridSizeZ; 1 <= ref2 ? l < ref2 : l > ref2; z = 1 <= ref2 ? ++l : --l) {
        if (x % gridSpacing === 0 && y % gridSpacing === 0) {
          particleAt[x][y][z] = elementName.indexOf("Fuse");
        }
        if (x % gridSpacing === 0 && z % gridSpacing === 0) {
          particleAt[x][y][z] = elementName.indexOf("Fuse");
        }
        if (y % gridSpacing === 0 && z % gridSpacing === 0) {
          particleAt[x][y][z] = elementName.indexOf("Fuse");
        }
      }
    }
  }
  return particleAt[Math.round(gridSizeX / 2)][Math.round(gridSizeY / 2)][Math.round(gridSizeZ / 2)] = elementName.indexOf("BurntFuse");
};

scenario19 = function() {
  var j, k, l, ref, ref1, ref2, theMaterial, x, y, z;
  theMaterial = elementName.indexOf("Fuse");
  for (x = j = 1, ref = gridSizeX; 1 <= ref ? j < ref : j > ref; x = 1 <= ref ? ++j : --j) {
    particleAt[x][Math.round(gridSizeY / 2)][Math.round(gridSizeZ / 2)] = theMaterial;
  }
  for (y = k = 1, ref1 = gridSizeY; 1 <= ref1 ? k < ref1 : k > ref1; y = 1 <= ref1 ? ++k : --k) {
    particleAt[Math.round(gridSizeX / 2)][y][Math.round(gridSizeZ / 2)] = theMaterial;
  }
  for (z = l = 1, ref2 = gridSizeY; 1 <= ref2 ? l < ref2 : l > ref2; z = 1 <= ref2 ? ++l : --l) {
    particleAt[Math.round(gridSizeX / 2)][Math.round(gridSizeY / 2)][z] = theMaterial;
  }
  return particleAt[Math.round(gridSizeX / 2)][Math.round(gridSizeY / 2)][Math.round(gridSizeZ / 2)] = elementName.indexOf("BurntFuse");
};
